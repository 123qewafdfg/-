<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0">
    <title>å°ç•ªèŒ„ Â· åŒå°„åŠ å¯† Â· è§†é¢‘+å›¾ç‰‡åˆå¹¶ç‰ˆ (WebGLä¿®å¤)</title>
    <!-- JSZip & FileSaver (ç”¨äºå›¾ç‰‡æ‰“åŒ…) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* ========== åˆå¹¶æ ·å¼ï¼šåŸºç¡€æ¥è‡ª2.htmlï¼Œè¡¥å……è§†é¢‘ç»†èŠ‚ ========== */
        * { box-sizing: border-box; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; }
        body { background: #1e1816; margin: 0; padding: 18px; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; }
        .tool-card { max-width: 1400px; width: 100%; background: #0f0c0a; border-radius: 32px; padding: 24px; box-shadow: 0 20px 36px rgba(0,0,0,0.6); border: 1px solid #44332c; }

        .module-tabs { display: flex; gap: 16px; margin-bottom: 24px; flex-wrap: wrap; align-items: center; }
        .module-tab { background: #231c19; color: #ffc5b1; padding: 12px 32px; border-radius: 60px; font-size: 1.3rem; font-weight: 600; border: 1px solid #5f4339; cursor: pointer; transition: all 0.1s; box-shadow: 0 4px 0 #120e0c; }
        .module-tab.active { background: #c44536; color: #fff3e6; border-color: #ff9e80; transform: translateY(-2px); box-shadow: 0 6px 0 #7a2e24; }
        .module-tab.inactive { opacity: 0.6; filter: grayscale(0.3); }
        .refresh-tab-btn { background: #2f2824; color: #ffbcac; padding: 10px 28px; border-radius: 40px; font-size: 1.2rem; border: 1px solid #7a5f54; cursor: pointer; margin-left: auto; box-shadow: 0 4px 0 #1a1412; transition: 0.1s; display: flex; align-items: center; gap: 6px; user-select: none; }
        .refresh-tab-btn:hover { background: #453a35; transform: translateY(-2px); box-shadow: 0 6px 0 #1a1412; }

        .module-page { display: none; }
        .module-page.active-page { display: block; }

        /* ---------- è§†é¢‘è§£å¯†é¡µé¢æ ·å¼ (è¡¥å……) ---------- */
        .main-decode-area { display: flex; gap: 28px; flex-wrap: wrap; }
        .video-preview-box { flex: 3; min-width: 600px; background: #8b7355; border-radius: 24px; padding: 16px 14px; border: 1px solid #d2b48c; box-shadow: 0 0 15px rgba(210, 180, 140, 0.5); }
        .video-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; color: #ffb7a0; flex-wrap: wrap; gap: 10px; }
        .video-wrapper { background: #000; border-radius: 18px; overflow: hidden; aspect-ratio: 16/9; position: relative; cursor: pointer; }
        canvas { width: 100%; height: 100%; object-fit: contain; display: block; background: #000; }

        .action-strip { flex: 0.8; min-width: 220px; display: flex; flex-direction: column; gap: 20px; background: #0f0c0a; padding: 20px 16px; border-radius: 32px; border: 1px solid #4b352d; }
        .action-btn, .img-action-btn {
            height: 4.4rem; border-radius: 60px; padding: 0 20px; font-size: 1.2rem; font-weight: 600;
            display: inline-flex; align-items: center; justify-content: center; gap: 12px; white-space: nowrap;
            box-shadow: 0 6px 0 #1c1512; border: 1px solid #6f554b; background: #312a26; color: #ffe1d4;
            cursor: pointer; transition: 0.05s;
        }
        .action-btn.primary, .img-action-btn.primary { background: #1f4a4a; border-color: #65b8b0; box-shadow: 0 6px 0 #0e2a2a; }
        .action-btn.primary:hover, .img-action-btn.primary:hover { background: #236b6b; transform: translateY(-2px); box-shadow: 0 8px 0 #0e2a2a; }
        .action-btn:hover, .img-action-btn:hover { background: #403630; transform: translateY(-2px); box-shadow: 0 8px 0 #1c1512; }
        .action-btn.file-select { position: relative; }
        .action-btn.file-select input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

        .img-action-btn.small { height: 3.6rem; padding: 0 18px; font-size: 1.05rem; box-shadow: 0 5px 0 #1c1512; }
        .mirror-toggle { display: none !important; }

        /* æŒ‰é’®ç¦ç”¨æ•ˆæœ */
        .action-btn:disabled, .img-action-btn:disabled, select:disabled {
            opacity: 0.55; filter: grayscale(0.5); cursor: not-allowed; pointer-events: auto;
        }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 1000; }
        .param-window { background: #1f1917; border-radius: 36px; padding: 32px; width: 520px; border: 2px solid #7a5f54; color: #ffdac9; box-shadow: 0 30px 50px black; }
        .param-window h3 { font-size: 1.8rem; margin-bottom: 24px; border-bottom: 2px solid #b16a5a; padding-bottom: 12px; }
        .param-row { margin-bottom: 24px; display: flex; flex-direction: column; gap: 8px; }
        .param-row label { font-weight: 600; color: #ffbcac; font-size: 1.1rem; }
        .param-row input, .param-row select { background: #2f2824; border: 1px solid #a77260; color: white; padding: 14px 18px; border-radius: 50px; font-size: 1.1rem; outline: none; }
        .radio-group { display: flex; gap: 30px; align-items: center; background: #2b221f; padding: 12px 20px; border-radius: 60px; }
        .btn-close { background: #c44536; border: none; color: white; padding: 16px 32px; border-radius: 60px; font-size: 1.3rem; font-weight: bold; width: 100%; cursor: pointer; margin-top: 16px; }

        .progress-section { margin-top: 24px; display: flex; align-items: center; gap: 20px; background: #231c19; padding: 12px 26px; border-radius: 60px; }
        progress { flex: 1; height: 12px; accent-color: #f0704a; background-color: #3a2e2a; border: 1px solid #6f554b; border-radius: 6px; }
        progress::-webkit-progress-bar { background-color: #3a2e2a; border-radius: 6px; }
        progress::-webkit-progress-value { background-color: #f0704a; border-radius: 6px; }
        #status-text { color: #ffd8c4; font-size: 1rem; }

        /* å›¾ç‰‡é¡µé¢ */
        .image-page-container { background: #080605; border-radius: 24px; padding: 16px 14px; border: 1px solid #543e36; color: #f0d9cf; margin-bottom: 20px; }
        .image-header-actions { display: flex; flex-direction: column; gap: 16px; margin-bottom: 20px; align-items: stretch; }
        .file-browse-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            gap: 12px; 
            flex-wrap: wrap;
        }
        .file-browse-row .img-action-btn {
            flex: 1;
            min-width: 120px;
            height: auto;
            min-height: 4rem;
            padding: 10px 16px;
            font-size: 1.1rem;
            white-space: normal;
            text-align: center;
        }
        .image-header-actions > div:nth-child(2) {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        .image-header-actions > div:nth-child(2) .img-action-btn {
            flex: 1;
            min-width: 120px;
            height: auto;
            min-height: 4rem;
            padding: 10px 16px;
            font-size: 1.1rem;
            white-space: normal;
            text-align: center;
        }
        .image-header-actions > div:nth-child(2) .mirror-toggle {
            white-space: normal;
            flex-shrink: 1;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }
        .reset-row { margin: 10px 0 8px 0; display: flex; align-items: center; }
        .key-section { background: #231e1b; border-radius: 60px; padding: 8px 18px 8px 28px; display: flex; align-items: center; flex-wrap: wrap; gap: 20px; border: 1px solid #785e52; margin: 20px 0; }
        .key-label { color: #ffb09c; font-weight: 500; }
        .key-value { background: #2f2723; border: 1px solid #b18472; border-radius: 60px; padding: 10px 22px; min-width: 240px; color: #ffe2d4; font-family: monospace; font-size: 1.2rem; border: none; outline: none; width: 300px; }
        .key-actions { display: flex; gap: 12px; margin-left: auto; flex-wrap: wrap; }

        .method-selector-bar { display: flex; align-items: center; gap: 16px; background: #1f1917; border-radius: 60px; padding: 12px 24px; margin: 16px 0 20px 0; border: 1px solid #7a5f54; flex-wrap: wrap; }
        .method-selector-bar span.label { color: #ffbcac; font-weight: 500; }
        .method-badge { background: #2b221f; padding: 6px 22px; border-radius: 40px; color: #ffd8c4; border: 1px solid #aa7b6b; font-size: 1.05rem; }

        .export-settings-popup { display: flex; gap: 20px; background: #2c221f; padding: 20px 28px; border-radius: 60px; align-items: center; margin-top: 20px; flex-wrap: wrap; }
        .export-settings-popup select { background: #1f1917; color: #ffd4c2; padding: 10px 26px; border-radius: 40px; border: 1px solid #aa7b6b; font-size: 1.1rem; }
        .export-settings-popup label { display: flex; align-items: center; gap: 8px; font-size: 1.1rem; color: #ffcfbe; cursor: pointer; white-space: nowrap; }
        .export-settings-popup input[type="checkbox"] { width: 20px; height: 20px; accent-color: #c44536; }

        .img-action-btn.highlight { background: #2a7a3a; border-color: #8feca0; box-shadow: 0 6px 0 #14521f; }
        .img-action-btn.highlight:hover { background: #359b48; }
        .img-action-btn.disabled { background: #c44536; border-color: #ff9e80; box-shadow: 0 6px 0 #7a2e24; }
        .img-action-btn.disabled:hover { background: #d65a48; }

        /* é¢„è§ˆå¼¹çª— (å›¾ç‰‡) */
        #previewModal .param-window { background: transparent !important; border: none !important; box-shadow: none !important; padding: 0 !important; width: auto !important; max-width: 90vw; }
        .preview-container { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .preview-img-wrapper { height: 60vh; width: 100%; display: flex; justify-content: center; align-items: center; background: #1a1a1a; border-radius: 16px; }
        #previewImg { max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 0 !important; background: #1a1a1a; box-shadow: 0 10px 30px rgba(0,0,0,0.6); cursor: pointer; }
        .preview-nav { display: flex; justify-content: center; align-items: center; gap: 40px; background: rgba(30, 24, 22, 0.8); backdrop-filter: blur(6px); padding: 12px 32px; border-radius: 60px; border: 1px solid #7a5a4c; }
        .preview-nav span { font-size: 3rem; cursor: pointer; user-select: none; color: #f0a58b; background: #2f2824; padding: 0 20px; border-radius: 60px; transition: 0.1s; line-height: 1.2; border: 1px solid #b17b68; }
        .preview-nav span:hover { background: #453a35; color: #ffcfbe; transform: scale(1.05); }
        .preview-nav .preview-counter { font-size: 1.4rem; color: #ffdac9; font-weight: 500; min-width: 100px; text-align: center; }

        #hidden-video { display: none; }

        /* ========== æ–°å¢å…è´£å£°æ˜æ ·å¼ ========== */
        .disclaimer {
            background: #1e1613;
            border-radius: 24px;
            padding: 24px 26px;
            margin-top: 32px;
            border: 1px solid #5c4238;
            color: #e6cfc2;
            font-size: 0.85rem;
            line-height: 1.6;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }
        .disclaimer h5 {
            margin: 0 0 16px 0;
            color: #ffb7a0;
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            border-left: 6px solid #c44536;
            padding-left: 16px;
        }
        .disclaimer p {
            margin: 12px 0;
        }
        .disclaimer strong {
            color: #ffaa91;
            font-weight: 600;
            margin-right: 6px;
        }
        .disclaimer a {
            color: #e69780;
            text-decoration: underline dotted;
        }
        .disclaimer a:hover {
            color: #ffbea6;
        }

        /* ç§»åŠ¨ç«¯é€‚é…è¡¥å…… */
        @media screen and (max-width: 750px) {
            body { padding: 10px; }
            .tool-card { padding: 16px; border-radius: 28px; }
            .module-tab { padding: 8px 18px; font-size: 1.1rem; }
            .video-preview-box { min-width: 100%; padding: 12px; }
            .video-header { flex-direction: column; align-items: flex-start; }
            .action-strip { min-width: 100%; padding: 16px; }
            .action-btn { height: auto; min-height: 4rem; white-space: normal; padding: 10px 16px; font-size: 1.1rem; }
            .progress-section { flex-wrap: wrap; gap: 10px; padding: 12px 16px; }
            .progress-section progress { width: 100%; }

            /* å›¾ç‰‡è§£å¯†é¡µé¢ç§»åŠ¨ç«¯é€‚é… */
            .image-header-actions { flex-direction: column; align-items: stretch; gap: 12px; }
            .file-browse-row { 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                gap: 10px; 
                flex-wrap: wrap;
            }
            .file-browse-row .img-action-btn {
                flex: 1;
                min-width: 80px;
                height: auto;
                min-height: 3rem;
                padding: 8px 12px;
                font-size: 0.9rem;
                white-space: normal;
                text-align: center;
            }
            .image-header-actions > div:nth-child(2) {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
                flex-wrap: wrap;
            }
            .image-header-actions > div:nth-child(2) .img-action-btn {
                flex: 1;
                min-width: 80px;
                height: auto;
                min-height: 3rem;
                padding: 8px 12px;
                font-size: 0.9rem;
                white-space: normal;
                text-align: center;
            }
            .image-header-actions > div:nth-child(2) .mirror-toggle {
                white-space: normal;
                flex-shrink: 1;
                flex: 1;
                min-width: 80px;
                text-align: center;
            }
            .img-action-btn.small { 
                height: auto; 
                min-height: 2.8rem; 
                padding: 6px 10px; 
                font-size: 0.9rem; 
            }
            .reset-row { 
                flex-wrap: wrap; 
                gap: 8px; 
                justify-content: center;
            }
            .key-section { 
                flex-direction: column; 
                align-items: stretch; 
                padding: 12px; 
                gap: 10px;
            }
            .key-value { 
                min-width: 0; 
                text-align: center; 
                word-break: break-all; 
                width: 100%;
                font-size: 1rem;
                padding: 8px 16px;
            }
            .key-actions { 
                margin-left: 0; 
                justify-content: center;
                gap: 8px;
            }
            .method-selector-bar { 
                flex-direction: column; 
                align-items: stretch; 
                text-align: center; 
                padding: 10px 16px;
                gap: 8px;
            }
            .export-settings-popup { 
                flex-direction: column; 
                align-items: stretch; 
                padding: 12px; 
                gap: 12px;
            }
            .export-settings-popup select { 
                width: 100%; 
                font-size: 1rem;
                padding: 8px 16px;
            }
            .export-settings-popup label { 
                font-size: 1rem;
                justify-content: center;
            }
            .param-window { 
                width: 92%; 
                padding: 20px; 
                max-height: 90vh;
                overflow-y: auto;
            }
            .disclaimer { 
                padding: 12px; 
                font-size: 0.8rem;
            }
            .preview-img-wrapper { 
                height: 50vh; 
            }
            .preview-nav { 
                gap: 20px;
                padding: 8px 16px;
            }
            .preview-nav span { 
                font-size: 2rem;
                padding: 0 12px;
            }
            .preview-counter { 
                font-size: 1.2rem;
                min-width: 80px;
            }
        }
        @media screen and (max-width: 400px) {
            .module-tab { padding: 6px 12px; font-size: 0.95rem; }
            .img-action-btn { 
                font-size: 0.9rem;
                padding: 6px 10px;
            }
            .key-value { 
                font-size: 0.9rem;
                padding: 6px 12px;
            }
            .method-badge { 
                font-size: 0.95rem;
                padding: 4px 16px;
            }
            .export-settings-popup select { 
                font-size: 0.9rem;
                padding: 6px 12px;
            }
            .export-settings-popup label { 
                font-size: 0.9rem;
            }
        }

        /* ä¸‹è½½å·¥å…·æŒ‰é’®æ ·å¼ */
        .download-tool-section {
            display: none;
            margin-top: 40px;
            text-align: center;
        }

        @media screen and (min-width: 1024px) {
            .download-tool-section {
                display: block;
            }
        }

        /* è§†é¢‘è§£å¯†å¤±è´¥è¯´æ˜æŒ‰é’®æ ·å¼ (ä»…ç§»åŠ¨ç«¯æ˜¾ç¤º) */
        .decrypt-fail-section {
            display: flex;
            justify-content: center;
            margin-top: 24px;
        }

        @media screen and (min-width: 1024px) {
            .decrypt-fail-section {
                display: none;
            }
        }

        .download-tool-btn {
            background: #c44536;
            border: 2px solid #ff9e80;
            color: #fff3e6;
            padding: 16px 40px;
            border-radius: 60px;
            font-size: 1.4rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 6px 0 #7a2e24;
            display: inline-flex;
            align-items: center;
            gap: 12px;
        }

        .download-tool-btn:hover {
            background: #d65a4a;
            transform: translateY(-3px);
            box-shadow: 0 8px 0 #7a2e24;
        }

        .download-tool-btn:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #7a2e24;
        }

        /* ä¸‹è½½å¼¹çª—æ ·å¼ */
        .download-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .download-modal {
            background: #1f1917;
            border-radius: 36px;
            padding: 32px;
            width: 90%;
            max-width: 600px;
            border: 2px solid #7a5f54;
            color: #ffdac9;
            box-shadow: 0 30px 50px rgba(0, 0, 0, 0.8);
            animation: slideIn 0.3s ease;
            position: relative;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .download-modal h3 {
            font-size: 1.8rem;
            margin-bottom: 24px;
            border-bottom: 2px solid #b16a5a;
            padding-bottom: 12px;
            text-align: center;
        }

        .download-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
            margin: 24px 0;
        }

        .download-button {
            background: #312a26;
            border: 1px solid #6f554b;
            color: #ffe1d4;
            padding: 16px 24px;
            border-radius: 60px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 #1c1512;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .download-button:hover {
            background: #403630;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1c1512;
        }

        .download-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1c1512;
        }

        .download-button.baidu {
            background: #1f4a4a;
            border-color: #65b8b0;
            box-shadow: 0 4px 0 #0e2a2a;
        }

        .download-button.baidu:hover {
            background: #236b6b;
            box-shadow: 0 6px 0 #0e2a2a;
        }

        .download-button.cloud123 {
            background: #4a1f1f;
            border-color: #b06565;
            box-shadow: 0 4px 0 #2a0e0e;
        }

        .download-button.cloud123:hover {
            background: #6b2323;
            box-shadow: 0 6px 0 #2a0e0e;
        }

        .download-button.quark {
            background: #1f1f4a;
            border-color: #6565b0;
            box-shadow: 0 4px 0 #0e0e2a;
        }

        .download-button.quark:hover {
            background: #23236b;
            box-shadow: 0 6px 0 #0e0e2a;
        }

        .close-download-modal {
            background: #c44536;
            border: none;
            color: white;
            padding: 14px 32px;
            border-radius: 60px;
            font-size: 1.2rem;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 #7a2e24;
        }

        .close-download-modal:hover {
            background: #d65a4a;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #7a2e24;
        }

        .close-download-modal:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #7a2e24;
        }

        .modal-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #2f2824;
            border: 1px solid #6f554b;
            color: #ffdac9;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        .modal-close-btn:hover {
            background: #403630;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
<div class="tool-card">
    <!-- æ ‡ç­¾é¡µ + åˆ·æ–°æŒ‰é’® -->
    <div class="module-tabs">
        <div class="module-tab active" id="tabVideoDecode">ğŸ¬ è§†é¢‘è§£å¯†</div>
        <div class="module-tab" id="tabImageDecode">ğŸ–¼ï¸ å›¾ç‰‡è§£å¯†</div>
        <span class="refresh-tab-btn" id="refreshCurrentBtn">ğŸ”„ åˆ·æ–°å½“å‰</span>
    </div>

    <!-- è§†é¢‘è§£å¯†é¡µé¢ (å®Œæ•´ç‰ˆ from 1.html) -->
    <div id="videoPage" class="module-page active-page">
        <div class="main-decode-area">
            <div class="video-preview-box">
                <div class="video-header">
                    <span style="background:#803f5e; padding:4px 18px; border-radius:40px;">ğŸ”“ è§£å¯†å®æ—¶é¢„è§ˆ</span>
                    <span id="video-dim"></span>
                    <!-- æ°´å¹³é•œåƒå¤é€‰æ¡† (éšè—ä½†å¼ºåˆ¶å¼€å¯) -->
                    <label class="mirror-toggle"><input type="checkbox" id="horizontalMirrorVideo" checked> ğŸª æ°´å¹³é•œåƒ</label>
                </div>
                <div class="video-wrapper" id="canvasFullscreenWrapper">
                    <canvas id="decodeCanvas"></canvas>
                </div>
            </div>
            <div class="action-strip">
                <div class="action-btn file-select">
                    ğŸ“‚ é€‰æ‹©è§†é¢‘
                    <input type="file" accept="video/*" id="videoFileInput">
                </div>
                <button class="action-btn primary" id="startDecodeBtn">âš¡ è§£å¯†æ‰§è¡Œ</button>
                <button class="action-btn" id="paramBtn">âš™ï¸ å‚æ•°è®¾ç½®</button>
                <div id="actionStatus" style="color: #ffd8c4; font-size: 1rem; text-align: center; margin-top: 10px; padding: 10px; background: #231c19; border-radius: 20px; border: 1px solid #4b352d;">å½“å‰æœªå¯¼å…¥è§†é¢‘ï¼Œè¯·é€‰æ‹©è§£å¯†çŠ¶æ€ã€‚</div>
            </div>
        </div>
        <div class="progress-section" style="display: none;">
            <span style="font-weight:600; color:#ffc5b1;">ğŸ“Š è§£å¯†è¿›åº¦</span>
            <progress id="decodeProgress" value="0" max="100"></progress>
            <span id="status-text">â¸ï¸ ç­‰å¾…è§†é¢‘é€‰æ‹©</span>
        </div>

        <!-- ========== è§†é¢‘é¡µé¢å…è´£å£°æ˜ ========== -->
        <div class="disclaimer">
            <h5>ç½‘ç«™å…è´£å£°æ˜</h5>
            <p><strong>ä¸€èˆ¬ä¿¡æ¯</strong> æœ¬ç½‘ç«™ä¸Šçš„æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºæ–‡å­—ã€å›¾å½¢ã€å›¾åƒã€ç…§ç‰‡ã€è§†é¢‘ã€éŸ³é¢‘ã€é“¾æ¥åŠå…¶ä»–ææ–™ï¼‰ä»…ä¾›å‚è€ƒã€‚æˆ‘ä»¬å°½åŠ›ç¡®ä¿ä¿¡æ¯çš„å‡†ç¡®æ€§å’Œæ—¶æ•ˆæ€§ï¼Œä½†ä¸ä½œä»»ä½•æ˜ç¤ºæˆ–æš—ç¤ºçš„ä¿è¯ã€‚</p>
            <p><strong>ä¸æ„æˆä¸“ä¸šå»ºè®®</strong> æœ¬ç½‘ç«™å†…å®¹ä¸æ„æˆä»»ä½•å½¢å¼çš„ä¸“ä¸šå»ºè®®ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºæ³•å¾‹ã€è´¢åŠ¡ã€åŒ»ç–—æˆ–æŠ€æœ¯å»ºè®®ï¼‰ã€‚åœ¨é‡‡å–ä»»ä½•åŸºäºæœ¬ç½‘ç«™ä¿¡æ¯çš„è¡ŒåŠ¨å‰ï¼Œè¯·å’¨è¯¢ç›¸å…³é¢†åŸŸçš„ä¸“ä¸šäººå£«ã€‚</p>
            <p><strong>å¤–éƒ¨é“¾æ¥å…è´£</strong> æœ¬ç½‘ç«™å¯èƒ½åŒ…å«æŒ‡å‘ç¬¬ä¸‰æ–¹ç½‘ç«™çš„è¶…é“¾æ¥ã€‚è¿™äº›é“¾æ¥ä»…ä¸ºæ–¹ä¾¿ç”¨æˆ·æä¾›ï¼Œä¸ä»£è¡¨æˆ‘ä»¬å¯¹å…¶å†…å®¹çš„è®¤å¯ã€‚æˆ‘ä»¬å¯¹ä»»ä½•é“¾æ¥ç½‘ç«™çš„å†…å®¹ã€éšç§æ”¿ç­–æˆ–å®è·µä¸æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚</p>
            <p><strong>è´£ä»»é™åˆ¶</strong> åœ¨æ³•å¾‹å…è®¸çš„æœ€å¤§èŒƒå›´å†…ï¼Œæˆ‘ä»¬ä¸å¯¹å› ä½¿ç”¨æˆ–æ— æ³•ä½¿ç”¨æœ¬ç½‘ç«™åŠå…¶å†…å®¹è€Œé€ æˆçš„ä»»ä½•ç›´æ¥ã€é—´æ¥ã€å¶ç„¶ã€ç‰¹æ®Šæˆ–åæœæ€§æŸå¤±æ‰¿æ‹…è´£ä»»ï¼Œå³ä½¿æˆ‘ä»¬å·²è¢«å‘ŠçŸ¥å¯èƒ½å‘ç”Ÿæ­¤ç±»æŸå¤±ã€‚</p>
            <p><strong>â€œæŒ‰åŸæ ·â€æä¾›</strong> æœ¬ç½‘ç«™åŠå…¶æ‰€æœ‰å†…å®¹å‡æŒ‰â€œåŸæ ·â€å’Œâ€œå¯ç”¨æ€§â€æä¾›ï¼Œä¸é™„å¸¦ä»»ä½•å½¢å¼çš„ä¿è¯ã€‚æˆ‘ä»¬ä¿ç•™éšæ—¶ä¿®æ”¹ã€æš‚åœæˆ–ç»ˆæ­¢ç½‘ç«™ä»»ä½•éƒ¨åˆ†çš„æƒåˆ©ï¼Œæ•ä¸å¦è¡Œé€šçŸ¥ã€‚</p>
            <p><strong>çŸ¥è¯†äº§æƒ</strong> é™¤éå¦æœ‰è¯´æ˜ï¼Œæœ¬ç½‘ç«™ä¸Šçš„æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºå•†æ ‡ã€å¾½æ ‡ã€è®¾è®¡ã€æ–‡æœ¬å’Œå›¾åƒï¼‰å‡ä¸ºæˆ‘ä»¬æˆ–æˆ‘ä»¬çš„è®¸å¯æ–¹çš„è´¢äº§ï¼Œå—ç‰ˆæƒå’Œå…¶ä»–çŸ¥è¯†äº§æƒæ³•ä¿æŠ¤ã€‚æœªç»æ˜ç¡®ä¹¦é¢è®¸å¯ï¼Œä¸å¾—å¤åˆ¶ã€åˆ†å‘æˆ–ç”¨äºå•†ä¸šç›®çš„ã€‚</p>
            <p><strong>ç”¨æˆ·è¡Œä¸º</strong> ç”¨æˆ·åœ¨ä½¿ç”¨æœ¬ç½‘ç«™æ—¶ï¼Œä¸å¾—ä»äº‹ä»»ä½•å¯èƒ½æŸå®³ã€ç˜«ç—ªæˆ–å¹²æ‰°ç½‘ç«™æ­£å¸¸è¿è¡Œçš„è¡Œä¸ºï¼Œä¹Ÿä¸å¾—å°è¯•æœªç»æˆæƒè®¿é—®ç½‘ç«™çš„å—é™éƒ¨åˆ†æˆ–ç³»ç»Ÿã€‚</p>
            <p><strong>ä¸ªäººè´£ä»»</strong> æ‚¨åŒæ„è‡ªè¡Œæ‰¿æ‹…ä½¿ç”¨æœ¬ç½‘ç«™åŠå…¶å†…å®¹çš„é£é™©ã€‚æ‚¨å¯¹ä¾èµ–æœ¬ç½‘ç«™ä¿¡æ¯æ‰€åšçš„ä»»ä½•å†³å®šå’Œè¡ŒåŠ¨è´Ÿå…¨éƒ¨è´£ä»»ã€‚</p>
            <p><strong>æ¡æ¬¾å˜æ›´</strong> æˆ‘ä»¬ä¿ç•™éšæ—¶æ›´æ–°ã€ä¿®æ”¹æˆ–æ›¿æ¢æœ¬å…è´£å£°æ˜ä»»ä½•éƒ¨åˆ†çš„æƒåˆ©ã€‚å˜æ›´åçš„å£°æ˜å°†åœ¨æœ¬é¡µé¢å…¬å¸ƒï¼Œå¹¶æ³¨æ˜æœ€åæ›´æ–°æ—¥æœŸã€‚æ‚¨æœ‰è´£ä»»å®šæœŸæŸ¥çœ‹æœ¬é¡µé¢ä»¥äº†è§£æœ€æ–°æ¡æ¬¾ã€‚</p>
            <p><strong>é€‚ç”¨æ³•å¾‹</strong> æœ¬å…è´£å£°æ˜å—ä¸­å›½æ³•å¾‹ç®¡è¾–å¹¶ä¾å…¶è§£é‡Šï¼Œä¸é€‚ç”¨å…¶æ³•å¾‹å†²çªåŸåˆ™ã€‚</p>
            <p style="margin-top:16px; color:#bda69a; font-size:0.8rem; border-top:1px dashed #5c4238; padding-top:10px;">æœ¬ç½‘ç«™ç”±DeepSeekç¼–å†™ã€‚</p>
        </div>
    </div>

    <!-- å›¾ç‰‡è§£å¯†é¡µé¢ (å®Œæ•´ç‰ˆ from 2.html) -->
    <div id="imagePage" class="module-page">
        <div class="image-page-container">
            <div class="image-header-actions">
                <div class="file-browse-row">
                    <button class="img-action-btn" id="browseImages">ğŸ“‚ æµè§ˆæ–‡ä»¶</button>
                    <button class="img-action-btn" id="exportConfigImg">ğŸ“ å¯¼å‡ºè‡³æ–‡ä»¶å¤¹</button>
                    <button class="img-action-btn primary" id="downloadAllBtn">ğŸ“¥ ä¸‹è½½æ‰€æœ‰</button>
                </div>
                <div>
                    <label class="mirror-toggle"><input type="checkbox" id="horizontalMirrorImage" checked> ğŸª æ°´å¹³é•œåƒ</label>
                    <button class="img-action-btn primary" id="startEncryptImg">ğŸ”’ å¼€å§‹åŠ å¯†</button>
                    <button class="img-action-btn primary" id="startDecryptImg">ğŸ”“ å¼€å§‹è§£å¯†</button>
                    <button class="img-action-btn" id="viewPreviewBtn">ğŸ” æŸ¥çœ‹é¢„è§ˆå›¾</button>
                </div>
            </div>

            <!-- è¿˜åŸæŒ‰é’®è¡Œ -->
            <div class="reset-row">
                <button class="img-action-btn small" id="resetToOriginalBtn">â†º è¿˜åŸåŸå›¾</button>
                <button class="img-action-btn small disabled" id="reencryptToggleBtn">ğŸš« ç¦æ­¢é‡åŠ å¯†</button>
            </div>

            <!-- å¤„ç†æŠ¥å‘Šè¡Œ + è¿›åº¦æ¡ + å›¾ç‰‡è®¡æ•° -->
            <div class="progress-section" style="margin-top:20px;">
                <progress id="imageProgress" value="0" max="100"></progress>
                <input type="text" readonly id="selectedCountDisplay" class="key-value" style="width:auto; max-width:160px; margin-left:auto; background:#2f2723; cursor:default;" value="0 å¼ å›¾ç‰‡">
            </div>

            <!-- å¯†é’¥åŒºåŸŸ -->
            <div class="key-section">
                <span class="key-label">ğŸ”‘ å¯†é’¥ï¼š</span>
                <input type="text" id="keyInputImg" class="key-value" placeholder="å¯ä¸ºç©º" value="">
                <div class="key-actions">
                    <button class="img-action-btn small" id="randomKeyBtn">ğŸ² éšæœºç”Ÿæˆ</button>
                    <button class="img-action-btn small" id="copyKeyBtn">ğŸ“‹ å¤åˆ¶å¯†é’¥</button>
                </div>
            </div>

            <!-- åŠ å¯†æ–¹å¼æ  -->
            <div class="method-selector-bar">
                <span class="label">ğŸ”§ åŠ å¯†æ–¹å¼ï¼š</span>
                <span class="method-badge" id="currentMethodDisplay">å‰å°”ä¼¯ç‰¹æ›²çº¿</span>
                <button class="img-action-btn small" id="chooseMethodBtn">é€‰æ‹©åŠ å¯†æ–¹å¼</button>
            </div>

            <!-- å¯¼å‡ºè®¾ç½®åŒº -->
            <div class="export-settings-popup">
                <span style="font-weight:600;">ğŸ“¸ å¯¼å‡ºè®¾ç½®</span>
                <select id="imgFormat">
                <option value="jpg95" selected>JPG (95% è´¨é‡)</option>
                <option value="png">PNG (æ— æŸ)</option>
                <option value="webp">WEBP (æ— æŸ)</option>
            </select>
                <label><input type="checkbox" id="packDownload"> æ‰“åŒ…ä¸‹è½½æ–‡ä»¶</label>
                <label><input type="checkbox" id="exportKeyFileCheckbox"> å¯¼å‡ºå¯†é’¥æ–‡ä»¶ï¼ˆTXTï¼‰</label>
            </div>

            <!-- ========== å›¾ç‰‡é¡µé¢å…è´£å£°æ˜ ========== -->
            <div class="disclaimer">
                <h5>ç½‘ç«™å…è´£å£°æ˜</h5>
                <p><strong>ä¸€èˆ¬ä¿¡æ¯</strong> æœ¬ç½‘ç«™ä¸Šçš„æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºæ–‡å­—ã€å›¾å½¢ã€å›¾åƒã€ç…§ç‰‡ã€è§†é¢‘ã€éŸ³é¢‘ã€é“¾æ¥åŠå…¶ä»–ææ–™ï¼‰ä»…ä¾›å‚è€ƒã€‚æˆ‘ä»¬å°½åŠ›ç¡®ä¿ä¿¡æ¯çš„å‡†ç¡®æ€§å’Œæ—¶æ•ˆæ€§ï¼Œä½†ä¸ä½œä»»ä½•æ˜ç¤ºæˆ–æš—ç¤ºçš„ä¿è¯ã€‚</p>
                <p><strong>ä¸æ„æˆä¸“ä¸šå»ºè®®</strong> æœ¬ç½‘ç«™å†…å®¹ä¸æ„æˆä»»ä½•å½¢å¼çš„ä¸“ä¸šå»ºè®®ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºæ³•å¾‹ã€è´¢åŠ¡ã€åŒ»ç–—æˆ–æŠ€æœ¯å»ºè®®ï¼‰ã€‚åœ¨é‡‡å–ä»»ä½•åŸºäºæœ¬ç½‘ç«™ä¿¡æ¯çš„è¡ŒåŠ¨å‰ï¼Œè¯·å’¨è¯¢ç›¸å…³é¢†åŸŸçš„ä¸“ä¸šäººå£«ã€‚</p>
                <p><strong>å¤–éƒ¨é“¾æ¥å…è´£</strong> æœ¬ç½‘ç«™å¯èƒ½åŒ…å«æŒ‡å‘ç¬¬ä¸‰æ–¹ç½‘ç«™çš„è¶…é“¾æ¥ã€‚è¿™äº›é“¾æ¥ä»…ä¸ºæ–¹ä¾¿ç”¨æˆ·æä¾›ï¼Œä¸ä»£è¡¨æˆ‘ä»¬å¯¹å…¶å†…å®¹çš„è®¤å¯ã€‚æˆ‘ä»¬å¯¹ä»»ä½•é“¾æ¥ç½‘ç«™çš„å†…å®¹ã€éšç§æ”¿ç­–æˆ–å®è·µä¸æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚</p>
                <p><strong>è´£ä»»é™åˆ¶</strong> åœ¨æ³•å¾‹å…è®¸çš„æœ€å¤§èŒƒå›´å†…ï¼Œæˆ‘ä»¬ä¸å¯¹å› ä½¿ç”¨æˆ–æ— æ³•ä½¿ç”¨æœ¬ç½‘ç«™åŠå…¶å†…å®¹è€Œé€ æˆçš„ä»»ä½•ç›´æ¥ã€é—´æ¥ã€å¶ç„¶ã€ç‰¹æ®Šæˆ–åæœæ€§æŸå¤±æ‰¿æ‹…è´£ä»»ï¼Œå³ä½¿æˆ‘ä»¬å·²è¢«å‘ŠçŸ¥å¯èƒ½å‘ç”Ÿæ­¤ç±»æŸå¤±ã€‚</p>
                <p><strong>â€œæŒ‰åŸæ ·â€æä¾›</strong> æœ¬ç½‘ç«™åŠå…¶æ‰€æœ‰å†…å®¹å‡æŒ‰â€œåŸæ ·â€å’Œâ€œå¯ç”¨æ€§â€æä¾›ï¼Œä¸é™„å¸¦ä»»ä½•å½¢å¼çš„ä¿è¯ã€‚æˆ‘ä»¬ä¿ç•™éšæ—¶ä¿®æ”¹ã€æš‚åœæˆ–ç»ˆæ­¢ç½‘ç«™ä»»ä½•éƒ¨åˆ†çš„æƒåˆ©ï¼Œæ•ä¸å¦è¡Œé€šçŸ¥ã€‚</p>
                <p><strong>çŸ¥è¯†äº§æƒ</strong> é™¤éå¦æœ‰è¯´æ˜ï¼Œæœ¬ç½‘ç«™ä¸Šçš„æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºå•†æ ‡ã€å¾½æ ‡ã€è®¾è®¡ã€æ–‡æœ¬å’Œå›¾åƒï¼‰å‡ä¸ºæˆ‘ä»¬æˆ–æˆ‘ä»¬çš„è®¸å¯æ–¹çš„è´¢äº§ï¼Œå—ç‰ˆæƒå’Œå…¶ä»–çŸ¥è¯†äº§æƒæ³•ä¿æŠ¤ã€‚æœªç»æ˜ç¡®ä¹¦é¢è®¸å¯ï¼Œä¸å¾—å¤åˆ¶ã€åˆ†å‘æˆ–ç”¨äºå•†ä¸šç›®çš„ã€‚</p>
                <p><strong>ç”¨æˆ·è¡Œä¸º</strong> ç”¨æˆ·åœ¨ä½¿ç”¨æœ¬ç½‘ç«™æ—¶ï¼Œä¸å¾—ä»äº‹ä»»ä½•å¯èƒ½æŸå®³ã€ç˜«ç—ªæˆ–å¹²æ‰°ç½‘ç«™æ­£å¸¸è¿è¡Œçš„è¡Œä¸ºï¼Œä¹Ÿä¸å¾—å°è¯•æœªç»æˆæƒè®¿é—®ç½‘ç«™çš„å—é™éƒ¨åˆ†æˆ–ç³»ç»Ÿã€‚</p>
                <p><strong>ä¸ªäººè´£ä»»</strong> æ‚¨åŒæ„è‡ªè¡Œæ‰¿æ‹…ä½¿ç”¨æœ¬ç½‘ç«™åŠå…¶å†…å®¹çš„é£é™©ã€‚æ‚¨å¯¹ä¾èµ–æœ¬ç½‘ç«™ä¿¡æ¯æ‰€åšçš„ä»»ä½•å†³å®šå’Œè¡ŒåŠ¨è´Ÿå…¨éƒ¨è´£ä»»ã€‚</p>
                <p><strong>æ¡æ¬¾å˜æ›´</strong> æˆ‘ä»¬ä¿ç•™éšæ—¶æ›´æ–°ã€ä¿®æ”¹æˆ–æ›¿æ¢æœ¬å…è´£å£°æ˜ä»»ä½•éƒ¨åˆ†çš„æƒåˆ©ã€‚å˜æ›´åçš„å£°æ˜å°†åœ¨æœ¬é¡µé¢å…¬å¸ƒï¼Œå¹¶æ³¨æ˜æœ€åæ›´æ–°æ—¥æœŸã€‚æ‚¨æœ‰è´£ä»»å®šæœŸæŸ¥çœ‹æœ¬é¡µé¢ä»¥äº†è§£æœ€æ–°æ¡æ¬¾ã€‚</p>
                <p><strong>é€‚ç”¨æ³•å¾‹</strong> æœ¬å…è´£å£°æ˜å—ä¸­å›½æ³•å¾‹ç®¡è¾–å¹¶ä¾å…¶è§£é‡Šï¼Œä¸é€‚ç”¨å…¶æ³•å¾‹å†²çªåŸåˆ™ã€‚</p>
                <p style="margin-top:16px; color:#bda69a; font-size:0.8rem; border-top:1px dashed #5c4238; padding-top:10px;">æœ¬ç½‘ç«™ç”±DeepSeekç¼–å†™ã€‚</p>
            </div>
        </div>
    </div>
    <div class="footer"></div>

    <!-- ä¸‹è½½å·¥å…·æŒ‰é’®åŒºåŸŸ -->
    <div class="download-tool-section">
        <button class="download-tool-btn" id="downloadToolBtn">
            ğŸ“¥ ä¸‹è½½è§†é¢‘åŠ å¯†å·¥å…·ï¼ˆç”µè„‘ç‰ˆï¼‰
        </button>
    </div>
    
    <!-- è§†é¢‘è§£å¯†å¤±è´¥è¯´æ˜æŒ‰é’® (ä»…ç§»åŠ¨ç«¯æ˜¾ç¤º) -->
    <div class="decrypt-fail-section">
        <button class="action-btn" id="decryptFailBtn">
            â“ æˆ‘ä¸ºä»€ä¹ˆè§†é¢‘è§£å¯†å¤±è´¥ï¼Ÿ
        </button>
    </div>
</div>

<!-- è§†é¢‘è§£å¯†å¤±è´¥è¯´æ˜å¼¹çª— -->
<div id="decryptFailModal" class="download-modal-overlay">
    <div class="download-modal">
        <button class="modal-close-btn" id="closeDecryptFailModalBtn">&times;</button>
        <h3>ğŸ” è§†é¢‘è§£å¯†å¤±è´¥åŸå› </h3>
        <p style="font-size: 1.2rem; line-height: 1.6; margin-bottom: 24px; text-align: center;">
            è§†é¢‘è§£å¯†å¤±è´¥å¯èƒ½æ˜¯æµè§ˆå™¨å…¼å®¹é—®é¢˜ï¼Œå»ºè®®æ›´æ¢æµè§ˆå™¨åé‡è¯•ã€‚
        </p>
        <div class="download-buttons">
            <a href="https://viayoo.com/zh-cn/" target="_blank" class="download-button baidu">
                ğŸ”— Via æµè§ˆå™¨ä¸‹è½½
            </a>
        </div>
        <button class="close-download-modal" id="closeDecryptFailModalBtnBottom">å…³é—­</button>
    </div>
</div>

<!-- ä¸‹è½½å¼¹çª— -->
<div id="downloadModal" class="download-modal-overlay">
    <div class="download-modal">
        <button class="modal-close-btn" id="closeDownloadModalBtn">&times;</button>
        <h3>ğŸ“¥ é€‰æ‹©ä¸‹è½½æ–¹å¼</h3>
        <div class="download-buttons">
            <a href="https://pan.baidu.com/s/1W_bvDtUPyDOgAvuMwJ5W4g?pwd=abwu" target="_blank" class="download-button baidu">
                ğŸ”— ç™¾åº¦ç½‘ç›˜ä¸‹è½½
            </a>
            <a href="https://www.123865.com/s/QL9VVv-q9AZh" target="_blank" class="download-button cloud123">
                ğŸ”— 123 äº‘ç›˜ä¸‹è½½
            </a>
            <a href="https://pan.quark.cn/s/6c00997f3996" target="_blank" class="download-button quark">
                ğŸ”— å¤¸å…‹äº‘ç›˜ä¸‹è½½
            </a>
        </div>
        <button class="close-download-modal" id="closeDownloadModalBtnBottom">å…³é—­</button>
    </div>
</div>

<!-- å…±ç”¨éšè—è§†é¢‘å…ƒç´  -->
<video id="hidden-video" crossorigin="anonymous" preload="auto" playsinline></video>

<!-- è§†é¢‘è§£å¯†å‚æ•°å¼¹çª— (æ¥è‡ª1.html) -->
<div id="paramModal" class="modal-overlay">
    <div class="param-window">
        <h3>ğŸ”§ è§†é¢‘è§£å¯†å‚æ•°</h3>
        <div class="param-row">
            <label>è§£å¯†æ–¹å¼</label>
            <div class="radio-group" id="decModeRadioGroup">
                <label><input type="radio" name="decMode" value="gilbert" checked> å‰å°”ä¼¯ç‰¹æ›²çº¿</label>
                <label><input type="radio" name="decMode" value="block"> å—æ‰“ä¹±</label>
            </div>
        </div>
        <div class="param-row">
            <label>å¯†é’¥ (å¯é€‰)</label>
            <input type="text" id="keyInput" placeholder="ç•™ç©ºè¡¨ç¤ºæ— å¯†é’¥" value="">
        </div>
        <div class="param-row" id="blockWidthRow">
            <label>å—å®½åº¦ (åƒç´ , ä»…å—æ‰“ä¹±)</label>
            <input type="number" id="blockWidth" value="16" min="8" max="256" step="8">
        </div>
        <div class="param-row" id="blockHeightRow">
            <label>å—é«˜åº¦ (åƒç´ )</label>
            <input type="number" id="blockHeight" value="16" min="8" max="256" step="8">
        </div>
        <!-- æ—‹è½¬180Â°å¤é€‰æ¡†ï¼šé»˜è®¤å‹¾é€‰ä¸”éšè— -->
        <div class="checkbox-row" id="rotateCheckboxRow" style="display: none;">
            <label><input type="checkbox" id="rotateCheckbox" checked> ğŸ”„ è¾“å‡ºæ—‹è½¬180Â° (å›ºå®šå¼€å¯)</label>
        </div>
        <button class="btn-close" id="closeParamBtn">ä¿å­˜å¹¶å…³é—­</button>
    </div>
</div>

<!-- å›¾ç‰‡åŠ å¯†æ–¹å¼é€‰æ‹©å¼¹çª— (æ¥è‡ª2.html) -->
<div id="encryptMethodModal" class="modal-overlay">
    <div class="param-window" style="width:560px;">
        <h3>âš™ï¸ é€‰æ‹©åŠ å¯†æ–¹å¼</h3>
        <div class="param-row">
            <div class="radio-group" id="imgEncryptModeGroup">
                <label><input type="radio" name="imgEncryptMode" value="gilbert" checked> å‰å°”ä¼¯ç‰¹æ›²çº¿</label>
                <label><input type="radio" name="imgEncryptMode" value="block"> åˆ†å—æ‰“ä¹±</label>
            </div>
        </div>
        <div id="imgBlockParams" style="display: none;">
            <div class="param-row">
                <label>å—å®½åº¦ (åƒç´ )</label>
                <select id="imgBlockWidthSelect"></select>
            </div>
            <div class="param-row">
                <label>å—é«˜åº¦ (åƒç´ )</label>
                <select id="imgBlockHeightSelect"></select>
            </div>
            <div style="display: flex; justify-content: flex-end; margin-bottom: 16px;">
                <button class="img-action-btn small" id="standardizeBtn" disabled>ğŸ“ æ ‡å‡†åŒ– (é«˜åº¦=å®½åº¦)</button>
            </div>
            <div id="blockHint" style="color: #ffa07a; font-size:0.9rem; padding:0 10px;"></div>
        </div>
        <button class="btn-close" id="saveEncryptMethodBtn">ä¿å­˜å¹¶å…³é—­</button>
    </div>
</div>

<!-- å›¾ç‰‡é¢„è§ˆå¼¹çª— (æ¥è‡ª2.html) -->
<div id="previewModal" class="modal-overlay" style="display: none;">
    <div class="param-window">
        <div class="preview-container">
            <div class="preview-img-wrapper">
                <img id="previewImg" src="" alt="é¢„è§ˆå›¾">
            </div>
            <div class="preview-nav">
                <span id="prevPreviewBtn">â†</span>
                <span class="preview-counter" id="previewCounter"></span>
                <span id="nextPreviewBtn">â†’</span>
            </div>
        </div>
    </div>
</div>

<!-- éšè—çš„å›¾ç‰‡æ–‡ä»¶é€‰æ‹©å™¨ -->
<input type="file" id="imageFilePicker" multiple accept="image/*" style="display: none;">

<script>
    // ==================== è§†é¢‘è§£å¯†æ¨¡å— (IIFE) ====================
    (function() {
        "use strict";

        // ---------- è§†é¢‘å…¨å±€å˜é‡ ----------
        const video = document.getElementById('hidden-video');
        const canvas = document.getElementById('decodeCanvas');
        const statusEl = document.getElementById('status-text');
        const progressBar = document.getElementById('decodeProgress');
        const actionStatus = document.getElementById('actionStatus');
        let videoWidth = 0, videoHeight = 0, totalPixels = 0;
        let isDecrypting = false;
        let currentFileURL = null;
        let decMode = 'gilbert', secretKey = '', blockW = 16, blockH = 16;
        const horizontalMirror = true;      // å›ºå®šå¼€å¯
        const rotateEnabled = true;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let isLandscapeVideo = false;

        // WebGL2ç›¸å…³
        let offscreenCanvas = null;
        let gl = null;
        let program = null;
        let uvTexture = null;
        let videoTexture = null;
        let vao = null;
        let uniformLoc = { videoSampler: null, uvSampler: null }; // åˆå§‹åŒ–ä¸ºnull
        let displayCtx = null;
        let currentDecryptMap = null;

        // ---------- å‰å°”ä¼¯ç‰¹æ›²çº¿ç®—æ³• (è¿”å›ç´¢å¼•æ•°ç»„) ----------
        function gilbert2d(width, height) {
            const coords = [];
            if (width >= height) {
                generate(0, 0, width, 0, 0, height, coords, width);
            } else {
                generate(0, 0, 0, height, width, 0, coords, width);
            }
            return coords;
        }
        function generate(x, y, ax, ay, bx, by, coords, imgWidth) {
            const w = Math.abs(ax + ay);
            const h = Math.abs(bx + by);
            const dax = Math.sign(ax) || 0, day = Math.sign(ay) || 0;
            const dbx = Math.sign(bx) || 0, dby = Math.sign(by) || 0;
            if (h === 1) {
                for (let i = 0; i < w; i++) {
                    coords.push(y * imgWidth + x);
                    x += dax; y += day;
                }
                return;
            }
            if (w === 1) {
                for (let i = 0; i < h; i++) {
                    coords.push(y * imgWidth + x);
                    x += dbx; y += dby;
                }
                return;
            }
            let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
            let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);
            if (2 * w > 3 * h) {
                if ((Math.abs(ax2 + ay2) % 2) !== 0 && w > 2) { ax2 += dax; ay2 += day; }
                generate(x, y, ax2, ay2, bx, by, coords, imgWidth);
                generate(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coords, imgWidth);
            } else {
                if ((Math.abs(bx2 + by2) % 2) !== 0 && h > 2) { bx2 += dbx; by2 += dby; }
                generate(x, y, bx2, by2, ax2, ay2, coords, imgWidth);
                generate(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coords, imgWidth);
                generate(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby),
                       -bx2, -by2, -(ax - ax2), -(ay - ay2), coords, imgWidth);
            }
        }
        function getGilbertIndices(w, h) { return new Uint32Array(gilbert2d(w, h)); }
        function getGilbertOffset(key, totalPixels) {
            if (!key) return Math.round((Math.sqrt(5) - 1) / 2 * totalPixels);
            else { let hash = 0; for (let i = 0; i < key.length; i++) hash = ((hash << 5) - hash) + key.charCodeAt(i); hash = Math.abs(hash); return hash % totalPixels; }
        }
        function buildGilbertDecryptMap(width, height, offset) {
            const total = width * height;
            const curve = getGilbertIndices(width, height);
            const rolled = new Uint32Array(total);
            for (let i = 0; i < total; i++) rolled[i] = curve[(i + offset) % total];
            const encMap = new Uint32Array(total);
            for (let i = 0; i < total; i++) encMap[curve[i]] = rolled[i];
            const map = new Uint32Array(total);
            for (let i = 0; i < total; i++) map[encMap[i]] = i;
            return map;
        }

        // ---------- å—æ‰“ä¹± ----------
        function simpleHash(str) { let h = 0; if (!str) return 123456; for (let i = 0; i < str.length; i++) { h = ((h << 5) - h) + str.charCodeAt(i); h |= 0; } return Math.abs(h); }
        function createSeededRNG(seed) { return function() { seed = (seed * 9301 + 49297) % 233280; return seed / 233280; } }
        function generateBlockOrder(numBlocks, key) {
            const seed = simpleHash(key);
            const rng = createSeededRNG(seed);
            const order = Array.from({length: numBlocks}, (_, i) => i);
            for (let i = order.length - 1; i > 0; i--) { const j = Math.floor(rng() * (i + 1)); [order[i], order[j]] = [order[j], order[i]]; }
            return order;
        }
        function buildBlockDecryptMap(width, height, blockW, blockH, key) {
            const cols = Math.ceil(width / blockW);
            const rows = Math.ceil(height / blockH);
            const totalBlocks = cols * rows;
            const encryptOrder = generateBlockOrder(totalBlocks, key);
            const blocks = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * blockW, y = row * blockH;
                    const w = Math.min(blockW, width - x), h = Math.min(blockH, height - y);
                    blocks.push({x, y, w, h, col, row, idx: row * cols + col});
                }
            }
            const decryptMap = new Uint32Array(width * height);
            for (let srcBlockIdx = 0; srcBlockIdx < totalBlocks; srcBlockIdx++) {
                const dstBlockIdx = encryptOrder[srcBlockIdx];
                const srcBlock = blocks[srcBlockIdx];
                const dstBlock = blocks[dstBlockIdx];
                for (let localY = 0; localY < srcBlock.h; localY++) {
                    for (let localX = 0; localX < srcBlock.w; localX++) {
                        const srcX = srcBlock.x + localX, srcY = srcBlock.y + localY;
                        const dstX = dstBlock.x + localX, dstY = dstBlock.y + localY;
                        if (dstX < width && dstY < height) {
                            const srcIdx = srcY * width + srcX;
                            const dstIdx = dstY * width + dstX;
                            decryptMap[srcIdx] = dstIdx;
                        }
                    }
                }
            }
            return decryptMap;
        }

        function generateRawDecryptMap() {
            if (!videoWidth || !videoHeight) throw new Error('è§†é¢‘å°ºå¯¸æœªå°±ç»ª');
            if (decMode === 'gilbert') {
                const offset = getGilbertOffset(secretKey, totalPixels);
                return buildGilbertDecryptMap(videoWidth, videoHeight, offset);
            } else {
                return buildBlockDecryptMap(videoWidth, videoHeight, blockW, blockH, secretKey);
            }
        }

        // ---------- WebGL2åˆå§‹åŒ– (å¢åŠ é”™è¯¯æ£€æŸ¥) ----------
        function initWebGL() {
            if (gl) return true; // å·²åˆå§‹åŒ–

            offscreenCanvas = document.createElement('canvas');
            gl = offscreenCanvas.getContext('webgl2', { alpha: false, desynchronized: true, antialias: false, depth: false, stencil: false, powerPreference: 'high-performance' });
            if (!gl) { 
                statusEl.innerText = 'æµè§ˆå™¨ä¸æ”¯æŒWebGL2ï¼Œæ— æ³•ä½¿ç”¨GPUåŠ é€Ÿ'; 
                return false;
            }
            displayCtx = canvas.getContext('2d');
            if (!displayCtx) { 
                statusEl.innerText = 'æ— æ³•è·å–2Dç”»å¸ƒä¸Šä¸‹æ–‡'; 
                gl = null; // æ¸…ç†
                return false;
            }

            const vsSrc = `#version 300 es
                layout(location = 0) in vec2 aPos;
                void main() {
                    gl_Position = vec4(aPos, 0.0, 1.0);
                }
            `;
            const fsSrc = `#version 300 es
                precision highp float;
                precision highp sampler2D;
                uniform sampler2D uVideoTex;
                uniform sampler2D uUvTex;
                out vec4 outColor;
                void main() {
                    ivec2 coord = ivec2(gl_FragCoord.xy);
                    vec4 uvData = texelFetch(uUvTex, coord, 0);
                    vec2 uv = uvData.rg;
                    outColor = texture(uVideoTex, uv);
                }
            `;
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSrc);
            gl.compileShader(vs);
            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                console.error('VS compile error:', gl.getShaderInfoLog(vs));
                statusEl.innerText = 'é¡¶ç‚¹ç€è‰²å™¨ç¼–è¯‘å¤±è´¥';
                gl = null; return false;
            }
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSrc);
            gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                console.error('FS compile error:', gl.getShaderInfoLog(fs));
                statusEl.innerText = 'ç‰‡æ®µç€è‰²å™¨ç¼–è¯‘å¤±è´¥';
                gl = null; return false;
            }
            program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Link error:', gl.getProgramInfoLog(program));
                statusEl.innerText = 'ç€è‰²å™¨é“¾æ¥å¤±è´¥';
                gl = null; return false;
            }
            gl.useProgram(program);

            // è·å–uniformä½ç½®å¹¶æ£€æŸ¥æœ‰æ•ˆæ€§
            uniformLoc.videoSampler = gl.getUniformLocation(program, 'uVideoTex');
            uniformLoc.uvSampler = gl.getUniformLocation(program, 'uUvTex');
            if (uniformLoc.videoSampler === null || uniformLoc.uvSampler === null) {
                console.error('Uniform location not found');
                statusEl.innerText = 'ç€è‰²å™¨uniformè·å–å¤±è´¥';
                gl = null; return false;
            }

            const vertices = new Float32Array([-1,-1, 3,-1, -1,3]);
            const vbo = gl.createBuffer(); 
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo); 
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            vao = gl.createVertexArray(); 
            gl.bindVertexArray(vao); 
            gl.enableVertexAttribArray(0); 
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0); 
            gl.bindVertexArray(null);

            videoTexture = gl.createTexture(); 
            gl.bindTexture(gl.TEXTURE_2D, videoTexture); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); 
            gl.bindTexture(gl.TEXTURE_2D, null);

            uvTexture = gl.createTexture(); 
            gl.bindTexture(gl.TEXTURE_2D, uvTexture); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); 
            gl.bindTexture(gl.TEXTURE_2D, null);

            statusEl.innerText = 'WebGL2å°±ç»ª (ç¦»å±æ¸²æŸ“)';
            return true;
        }

        function updateUvTextureFromMap(map, width, height) {
            if (!gl || !uvTexture) return;
            const total = width * height;
            const uvData = new Float32Array(total * 4);
            for (let dstIdx = 0; dstIdx < total; dstIdx++) {
                const srcIdx = map[dstIdx];
                const srcX = srcIdx % width;
                const srcY = Math.floor(srcIdx / width);
                const u = (srcX + 0.5) / width;
                const v = (srcY + 0.5) / height;
                uvData[dstIdx*4] = u; uvData[dstIdx*4+1] = v;
            }
            gl.bindTexture(gl.TEXTURE_2D, uvTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, uvData);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function webglRenderFrame() {
            if (!gl || !program || !video.videoWidth) return false;
            // ç¡®ä¿uniformä½ç½®æœ‰æ•ˆ
            if (uniformLoc.videoSampler === null || uniformLoc.uvSampler === null) return false;

            if (offscreenCanvas.width !== video.videoWidth || offscreenCanvas.height !== video.videoHeight) {
                offscreenCanvas.width = video.videoWidth; offscreenCanvas.height = video.videoHeight;
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                gl.viewport(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            }
            gl.activeTexture(gl.TEXTURE0); 
            gl.bindTexture(gl.TEXTURE_2D, videoTexture); 
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            gl.activeTexture(gl.TEXTURE1); 
            gl.bindTexture(gl.TEXTURE_2D, uvTexture);
            gl.useProgram(program); 
            // è®¾ç½®uniform samplerå€¼
            gl.uniform1i(uniformLoc.videoSampler, 0); 
            gl.uniform1i(uniformLoc.uvSampler, 1);
            gl.bindVertexArray(vao); 
            gl.drawArrays(gl.TRIANGLES, 0, 3); 
            gl.bindVertexArray(null);
            // åå¤„ç†ï¼šæ—‹è½¬180Â°å›ºå®š + æ°´å¹³é•œåƒå¼ºåˆ¶
            displayCtx.clearRect(0, 0, canvas.width, canvas.height);
            displayCtx.save();
            const w = canvas.width, h = canvas.height;
            displayCtx.translate(w/2, h/2);
            displayCtx.scale(-1, 1);        // æ°´å¹³é•œåƒå¼ºåˆ¶
            displayCtx.rotate(Math.PI);      // æ—‹è½¬180Â°å›ºå®š
            displayCtx.drawImage(offscreenCanvas, -w/2, -h/2, w, h);
            displayCtx.restore();
            return true;
        }

        function stopDecoding() { isDecrypting = false; if (video) video.pause(); }
        window.videoStopDecoding = stopDecoding;   // ä¾›tabåˆ‡æ¢è°ƒç”¨

        function startDecode() {
            if (!video.src) { statusEl.innerText = 'è¯·å…ˆé€‰æ‹©è§†é¢‘'; actionStatus.innerText = 'å½“å‰æœªå¯¼å…¥è§†é¢‘ï¼Œè¯·é€‰æ‹©è§£å¯†çŠ¶æ€ã€‚'; return; }
            if (!video.videoWidth) { statusEl.innerText = 'è§†é¢‘æœªå®Œå…¨åŠ è½½'; return; }
            stopDecoding();
            videoWidth = video.videoWidth; videoHeight = video.videoHeight;
            totalPixels = videoWidth * videoHeight;
            canvas.width = videoWidth; canvas.height = videoHeight;
            if (offscreenCanvas) { offscreenCanvas.width = videoWidth; offscreenCanvas.height = videoHeight; }
            if (!initWebGL()) { 
                statusEl.innerText = 'WebGL2åˆå§‹åŒ–å¤±è´¥ï¼Œæ— æ³•è§£å¯†'; 
                return; 
            }
            try { 
                currentDecryptMap = generateRawDecryptMap(); 
            } catch (e) { 
                statusEl.innerText = 'æ˜ å°„ç”Ÿæˆå¤±è´¥'; 
                return; 
            }
            updateUvTextureFromMap(currentDecryptMap, videoWidth, videoHeight);
            isDecrypting = true;
            actionStatus.innerText = 'å·²é€‰å®šè§£å¯†æ¨¡å¼ï¼Œæ­£åœ¨è§£å¯†ä¸­';
            video.play().then(() => {
                function rafLoop() {
                    if (!isDecrypting || video.paused || video.ended) return;
                    webglRenderFrame();
                    if (video.duration) progressBar.value = (video.currentTime / video.duration) * 100;
                    requestAnimationFrame(rafLoop);
                }
                rafLoop();
                statusEl.innerText = 'è§£å¯†æ’­æ”¾ä¸­';
            }).catch((e) => { 
                isDecrypting = false; 
                statusEl.innerText = 'æ’­æ”¾å¤±è´¥: ' + e.message; 
                actionStatus.innerText = 'å·²é€‰æ‹©è§£å¯†çŠ¶æ€ï¼Œè¯·ç¡®è®¤è§£å¯†æ¨¡å¼ã€‚';
            });
            video.onended = () => { isDecrypting = false; statusEl.innerText = 'æ’­æ”¾ç»“æŸ'; actionStatus.innerText = 'å·²é€‰æ‹©è§£å¯†çŠ¶æ€ï¼Œè¯·ç¡®è®¤è§£å¯†æ¨¡å¼ã€‚'; };
        }

        // äº‹ä»¶ç»‘å®š
        document.getElementById('videoFileInput').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            isDecrypting = false;
            if (currentFileURL) URL.revokeObjectURL(currentFileURL);
            currentFileURL = URL.createObjectURL(file);
            video.src = currentFileURL; video.load(); video.pause();
            statusEl.innerText = 'è§†é¢‘åŠ è½½ä¸­...';
            actionStatus.innerText = 'å·²é€‰æ‹©è§£å¯†çŠ¶æ€ï¼Œè¯·ç¡®è®¤è§£å¯†æ¨¡å¼ã€‚';
            video.onloadedmetadata = () => {
                videoWidth = video.videoWidth;
                videoHeight = video.videoHeight;
                if (videoWidth && videoHeight) {
                    canvas.width = videoWidth;
                    canvas.height = videoHeight;
                    if (offscreenCanvas) { offscreenCanvas.width = videoWidth; offscreenCanvas.height = videoHeight; }
                    document.getElementById('video-dim').innerText = `${videoWidth}x${videoHeight}`;
                    // æ£€æµ‹æ˜¯å¦ä¸ºæ¨ªå±è§†é¢‘
                    isLandscapeVideo = videoWidth > videoHeight;
                    statusEl.innerText = 'è§†é¢‘å°±ç»ªï¼Œå¯ç‚¹å‡»è§£å¯†æ‰§è¡Œ';
                    actionStatus.innerText = 'å·²é€‰æ‹©è§£å¯†çŠ¶æ€ï¼Œè¯·ç¡®è®¤è§£å¯†æ¨¡å¼ã€‚';
                }
            };
            video.onerror = () => { statusEl.innerText = 'è§†é¢‘åŠ è½½å¤±è´¥'; actionStatus.innerText = 'å½“å‰æœªå¯¼å…¥è§†é¢‘ï¼Œè¯·é€‰æ‹©è§£å¯†çŠ¶æ€ã€‚'; };
        });
        document.getElementById('startDecodeBtn').addEventListener('click', startDecode);
        // ä¸‹è½½å·¥å…·æŒ‰é’®äº‹ä»¶
        document.getElementById('downloadToolBtn').addEventListener('click', () => {
            document.getElementById('downloadModal').style.display = 'flex';
        });

        // å…³é—­ä¸‹è½½å¼¹çª—äº‹ä»¶
        document.getElementById('closeDownloadModalBtn').addEventListener('click', () => {
            document.getElementById('downloadModal').style.display = 'none';
        });

        document.getElementById('closeDownloadModalBtnBottom').addEventListener('click', () => {
            document.getElementById('downloadModal').style.display = 'none';
        });

        // ç‚¹å‡»é®ç½©å…³é—­å¼¹çª—
        document.getElementById('downloadModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('downloadModal')) {
                document.getElementById('downloadModal').style.display = 'none';
            }
        });

        document.getElementById('paramBtn').addEventListener('click', () => {
            document.querySelector(`input[name="decMode"][value="${decMode}"]`).checked = true;
            document.getElementById('keyInput').value = secretKey;
            document.getElementById('blockWidth').value = blockW;
            document.getElementById('blockHeight').value = blockH;
            document.getElementById('blockWidthRow').style.display = decMode==='block'?'flex':'none';
            document.getElementById('blockHeightRow').style.display = decMode==='block'?'flex':'none';
            document.getElementById('paramModal').style.display = 'flex';
        });
        document.querySelectorAll('input[name="decMode"]').forEach(r => r.addEventListener('change', function(e) {
            const mode = e.target.value;
            document.getElementById('blockWidthRow').style.display = mode==='block'?'flex':'none';
            document.getElementById('blockHeightRow').style.display = mode==='block'?'flex':'none';
        }));
        document.getElementById('closeParamBtn').addEventListener('click', () => {
            decMode = document.querySelector('input[name="decMode"]:checked').value;
            secretKey = document.getElementById('keyInput').value;
            blockW = parseInt(document.getElementById('blockWidth').value,10) || 16;
            blockH = parseInt(document.getElementById('blockHeight').value,10) || 16;
            document.getElementById('paramModal').style.display = 'none';
            statusEl.innerText = video.src ? 'å‚æ•°å·²æ›´æ–°' : 'è¯·å…ˆé€‰æ‹©è§†é¢‘';
            actionStatus.innerText = video.src ? 'å·²é€‰å®šè§£å¯†æ¨¡å¼ï¼Œæ­£åœ¨è§£å¯†ä¸­' : 'å½“å‰æœªå¯¼å…¥è§†é¢‘ï¼Œè¯·é€‰æ‹©è§£å¯†çŠ¶æ€ã€‚';
        });
        window.addEventListener('click', (e) => { if (e.target === document.getElementById('paramModal')) document.getElementById('paramModal').style.display = 'none'; });

        // è¿›åº¦æ¡æ‹–åŠ¨
        let seeking = false;
        progressBar.addEventListener('mousedown',()=>{ seeking = true; });
        progressBar.addEventListener('input', function(e) { if(video.duration) video.currentTime = (e.target.value/100)*video.duration; });
        progressBar.addEventListener('mouseup', ()=>{ seeking = false; });
        video.addEventListener('timeupdate', ()=>{ if(!seeking && video.duration) progressBar.value = (video.currentTime/video.duration)*100; });

        // åŒå‡»è¿›å…¥/é€€å‡ºå…¨å±
        let clickCount = 0;
        let clickTimer = null;
        document.getElementById('canvasFullscreenWrapper').addEventListener('click', () => {
            clickCount++;
            if (clickCount === 1) {
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                }, 300);
            } else if (clickCount === 2) {
                clearTimeout(clickTimer);
                clickCount = 0;
                const wrap = document.getElementById('canvasFullscreenWrapper');
                if (!document.fullscreenElement) {
                    // è¿›å…¥å…¨å±
                    console.log('Entering fullscreen - isMobile:', isMobile, 'isLandscapeVideo:', isLandscapeVideo, 'videoWidth:', videoWidth, 'videoHeight:', videoHeight);
                    wrap.requestFullscreen().then(() => {
                        console.log('Fullscreen entered successfully');
                    }).catch(err => {
                        console.error('Error entering fullscreen:', err);
                    });
                } else {
                    // é€€å‡ºå…¨å±
                    console.log('Exiting fullscreen');
                    document.exitFullscreen();
                }
            }
        });

        // å…¨å±æ»‘åŠ¨æ§åˆ¶
        let touchStartX = 0;
        let touchStartTime = 0;
        const swipeThreshold = 50; // æœ€å°æ»‘åŠ¨è·ç¦»
        const swipeTimeThreshold = 500; // æœ€å¤§æ»‘åŠ¨æ—¶é—´
        
        function handleSwipe(deltaX, deltaTime) {
            if (Math.abs(deltaX) < swipeThreshold || deltaTime > swipeTimeThreshold) return;
            
            // è®¡ç®—æ»‘åŠ¨é€Ÿåº¦å’Œè·ç¦»ï¼Œæ˜ å°„åˆ°ç§’æ•°
            const swipeSpeed = Math.abs(deltaX) / deltaTime; // åƒç´ /æ¯«ç§’
            const seekSeconds = Math.max(1, Math.min(10, Math.floor(Math.abs(deltaX) / 50)));
            
            if (deltaX > 0) {
                // å‘å³æ»‘åŠ¨ï¼Œå¿«è¿›
                video.currentTime = Math.min(video.duration, video.currentTime + seekSeconds);
            } else {
                // å‘å·¦æ»‘åŠ¨ï¼Œå›é€€
                video.currentTime = Math.max(0, video.currentTime - seekSeconds);
            }
        }

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            if (!document.fullscreenElement) return;
            touchStartX = e.clientX;
            touchStartTime = Date.now();
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!document.fullscreenElement) return;
            const touchEndX = e.clientX;
            const touchEndTime = Date.now();
            const deltaX = touchEndX - touchStartX;
            const deltaTime = touchEndTime - touchStartTime;
            handleSwipe(deltaX, deltaTime);
        });

        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => {
            if (!document.fullscreenElement) return;
            touchStartX = e.touches[0].clientX;
            touchStartTime = Date.now();
        });

        canvas.addEventListener('touchend', (e) => {
            if (!document.fullscreenElement) return;
            if (e.changedTouches.length > 0) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndTime = Date.now();
                const deltaX = touchEndX - touchStartX;
                const deltaTime = touchEndTime - touchStartTime;
                handleSwipe(deltaX, deltaTime);
            }
        });



        // ç›‘å¬å…¨å±çŠ¶æ€å˜åŒ–
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                // è¿›å…¥å…¨å±
                console.log('Fullscreen entered - isMobile:', isMobile, 'isLandscapeVideo:', isLandscapeVideo);
                if (isMobile && isLandscapeVideo) {
                    console.log('Applying landscape rotation');
                    // å¯¹äºç§»åŠ¨è®¾å¤‡æ¨ªå±è§†é¢‘ï¼Œå¼ºåˆ¶æ¨ªå±æ˜¾ç¤º
                    const fullscreenElement = document.fullscreenElement;
                    if (fullscreenElement) {
                        // ä¿å­˜åŸå§‹æ ·å¼
                        fullscreenElement.dataset.originalStyle = fullscreenElement.style.cssText;
                        
                        // åº”ç”¨æ¨ªå±æ ·å¼
                        fullscreenElement.style.width = '100%';
                        fullscreenElement.style.height = '100%';
                        fullscreenElement.style.objectFit = 'contain';
                        
                        // è°ƒæ•´body
                        document.body.style.orientation = 'landscape';
                        document.body.style.width = '100%';
                        document.body.style.height = '100%';
                        document.body.style.margin = '0';
                        document.body.style.padding = '0';
                        document.body.style.overflow = 'hidden';
                    }
                }
            } else {
                // é€€å‡ºå…¨å±
                console.log('Fullscreen exited');
                // æ¢å¤å…¨å±å…ƒç´ æ ·å¼
                const wrap = document.getElementById('canvasFullscreenWrapper');
                if (wrap.dataset.originalStyle) {
                    wrap.style.cssText = wrap.dataset.originalStyle;
                    delete wrap.dataset.originalStyle;
                }
                
                // æ¢å¤bodyæ ·å¼ï¼ˆæ— è®ºæ˜¯å¦æ˜¯ç§»åŠ¨è®¾å¤‡æˆ–æ¨ªå±è§†é¢‘ï¼Œéƒ½éœ€è¦æ¢å¤ï¼‰
                document.body.style.orientation = '';
                document.body.style.width = '';
                document.body.style.height = '';
                document.body.style.margin = '';
                document.body.style.padding = '';
                document.body.style.overflow = '';
            }
        });

        window.addEventListener('beforeunload', () => { if (currentFileURL) URL.revokeObjectURL(currentFileURL); });
        // æ°´å¹³é•œåƒå¼ºåˆ¶å¼€å¯
        const mirrorV = document.getElementById('horizontalMirrorVideo'); if (mirrorV) mirrorV.checked = true;
    })();

    // ==================== å›¾ç‰‡è§£å¯†æ¨¡å— (IIFE) ====================
    (function() {
        "use strict";
        // å›¾ç‰‡é¡µé¢å…ƒç´ 
        const imagePicker = document.getElementById('imageFilePicker');
        const browseBtn = document.getElementById('browseImages');
        const viewPreviewBtn = document.getElementById('viewPreviewBtn');
        const previewModal = document.getElementById('previewModal');
        const prevBtn = document.getElementById('prevPreviewBtn');
        const nextBtn = document.getElementById('nextPreviewBtn');
        const previewImg = document.getElementById('previewImg');
        const previewCounter = document.getElementById('previewCounter');
        const startEncrypt = document.getElementById('startEncryptImg');
        const startDecrypt = document.getElementById('startDecryptImg');
        const keyInput = document.getElementById('keyInputImg');
        const randomKeyBtn = document.getElementById('randomKeyBtn');
        const copyKeyBtn = document.getElementById('copyKeyBtn');
        const exportConfigBtn = document.getElementById('exportConfigImg');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const chooseMethodBtn = document.getElementById('chooseMethodBtn');
        const currentMethodDisplay = document.getElementById('currentMethodDisplay');
        const encryptMethodModal = document.getElementById('encryptMethodModal');
        const imgEncryptRadios = document.querySelectorAll('input[name="imgEncryptMode"]');
        const imgBlockParamsDiv = document.getElementById('imgBlockParams');
        const imgBlockWidthSelect = document.getElementById('imgBlockWidthSelect');
        const imgBlockHeightSelect = document.getElementById('imgBlockHeightSelect');
        const standardizeBtn = document.getElementById('standardizeBtn');
        const saveEncryptMethodBtn = document.getElementById('saveEncryptMethodBtn');
        const blockHint = document.getElementById('blockHint');
        const packCheck = document.getElementById('packDownload');
        const exportKeyCheck = document.getElementById('exportKeyFileCheckbox');
        const imgFormatSelect = document.getElementById('imgFormat');
        const imageProgress = document.getElementById('imageProgress');
        const selectedCountDisplay = document.getElementById('selectedCountDisplay');
        const resetBtn = document.getElementById('resetToOriginalBtn');
        const reencryptToggleBtn = document.getElementById('reencryptToggleBtn');
        const mirrorImg = document.getElementById('horizontalMirrorImage'); if (mirrorImg) mirrorImg.checked = true;

        // çŠ¶æ€å˜é‡
        let selectedImageFiles = [];
        let previewUrls = [];
        let currentPreviewIndex = 0;
        let imgMethod = 'gilbert';
        let imgBlockW = 1, imgBlockH = 1;
        let latestProcessedImages = [];
        let latestKeyParams = null;
        let isProcessing = false;
        let isReencryptEnabled = false;
        let cachedFirstImageWidth = null, cachedFirstImageHeight = null, cachedFirstImageName = '';
        const mapCache = new Map();

        // é‡åŠ å¯†åŠŸèƒ½åˆ‡æ¢
        reencryptToggleBtn.addEventListener('click', function() {
            isReencryptEnabled = !isReencryptEnabled;
            if (isReencryptEnabled) {
                reencryptToggleBtn.innerHTML = 'âœ… å…è®¸é‡åŠ å¯†';
                reencryptToggleBtn.classList.remove('disabled');
                reencryptToggleBtn.classList.add('highlight');
                // å¼€å¯å…è®¸é‡åŠ å¯†æ—¶ï¼Œå¯ç”¨åŠ å¯†å’Œè§£å¯†æŒ‰é’®
                enableExportControls();
            } else {
                reencryptToggleBtn.innerHTML = 'ğŸš« ç¦æ­¢é‡åŠ å¯†';
                reencryptToggleBtn.classList.remove('highlight');
                reencryptToggleBtn.classList.add('disabled');
            }
        });

        // è¾…åŠ©å“ˆå¸Œ
        function simpleHash(s) { let h=0; for(let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); }

        // å‰å°”ä¼¯ç‰¹æ›²çº¿ (è¿”å›åæ ‡æ•°ç»„)
        function gilbert2d(width, height) {
            const coordinates = [];
            if (width >= height) generate2d(0, 0, width, 0, 0, height, coordinates);
            else generate2d(0, 0, 0, height, width, 0, coordinates);
            return coordinates;
        }
        function generate2d(x, y, ax, ay, bx, by, coordinates) {
            const w = Math.abs(ax + ay), h = Math.abs(bx + by);
            const dax = Math.sign(ax), day = Math.sign(ay), dbx = Math.sign(bx), dby = Math.sign(by);
            if (h === 1) { for (let i = 0; i < w; i++) { coordinates.push([x, y]); x += dax; y += day; } return; }
            if (w === 1) { for (let i = 0; i < h; i++) { coordinates.push([x, y]); x += dbx; y += dby; } return; }
            let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2), bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);
            const w2 = Math.abs(ax2 + ay2), h2 = Math.abs(bx2 + by2);
            if (2 * w > 3 * h) {
                if ((w2 % 2) && (w > 2)) { ax2 += dax; ay2 += day; }
                generate2d(x, y, ax2, ay2, bx, by, coordinates);
                generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);
            } else {
                if ((h2 % 2) && (h > 2)) { bx2 += dbx; by2 += dby; }
                generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
                generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
                generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby), -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
            }
        }

        function buildGilbertEncryptMap(width, height, key) {
            const total = width * height;
            const curveCoords = gilbert2d(width, height);
            let offset = key ? simpleHash(key) % total : Math.round((Math.sqrt(5)-1)/2 * total);
            const encMap = new Uint32Array(total);
            for (let i = 0; i < total; i++) {
                const oldPos = curveCoords[i];
                const oldLinear = oldPos[1] * width + oldPos[0];
                const newPos = curveCoords[(i + offset) % total];
                const newLinear = newPos[1] * width + newPos[0];
                encMap[newLinear] = oldLinear;
            }
            return encMap;
        }

        function buildBlockEncryptMap(width, height, blockW, blockH, key) {
            const cols = Math.ceil(width / blockW), rows = Math.ceil(height / blockH);
            const totalBlocks = cols * rows;
            let seed = key ? simpleHash(key) : 123456;
            function rng() { seed = (seed * 9301 + 49297) % 233280; return seed / 233280; }
            const perm = Array.from({length: totalBlocks}, (_,i)=>i);
            for (let i=perm.length-1; i>0; i--) { const j = Math.floor(rng() * (i+1)); [perm[i], perm[j]] = [perm[j], perm[i]]; }
            const blocks = [];
            for (let r=0; r<rows; r++) for (let c=0; c<cols; c++) {
                const x = c*blockW, y = r*blockH, w = Math.min(blockW, width-x), h = Math.min(blockH, height-y);
                blocks.push({x, y, w, h, idx: r*cols + c});
            }
            const encMap = new Uint32Array(width * height);
            for (let dstIdx = 0; dstIdx < width*height; dstIdx++) {
                const dstY = Math.floor(dstIdx / width), dstX = dstIdx % width;
                const dstCol = Math.floor(dstX / blockW), dstRow = Math.floor(dstY / blockH);
                const dstBlockIdx = dstRow * cols + dstCol;
                const srcBlockIdx = perm[dstBlockIdx];
                const srcBlock = blocks[srcBlockIdx];
                const localX = dstX - dstCol*blockW, localY = dstY - dstRow*blockH;
                let srcX = srcBlock.x + localX, srcY = srcBlock.y + localY;
                if (srcX >= width) srcX = width-1; if (srcY >= height) srcY = height-1;
                encMap[dstIdx] = srcY * width + srcX;
            }
            return encMap;
        }
        function invertMap(map, len) { const inv = new Uint32Array(len); for (let i=0; i<len; i++) inv[map[i]] = i; return inv; }

        async function processImage(file, mode, blockW, blockH) {
            const bitmap = await createImageBitmap(file);
            const width = bitmap.width, height = bitmap.height;
            const canvas = new OffscreenCanvas(width, height);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const totalPixels = width * height;
            const keyStr = keyInput.value || '';
            let cacheKey = (imgMethod === 'gilbert') ? `gilbert:${width}:${height}:${keyStr}` : `block:${width}:${height}:${keyStr}:${blockW}:${blockH}`;
            let encMap, invMap;
            if (mapCache.has(cacheKey)) {
                const pair = mapCache.get(cacheKey); encMap = pair.encMap; invMap = pair.invMap;
            } else {
                if (imgMethod === 'gilbert') encMap = buildGilbertEncryptMap(width, height, keyStr);
                else encMap = buildBlockEncryptMap(width, height, blockW, blockH, keyStr);
                invMap = invertMap(encMap, totalPixels);
                mapCache.set(cacheKey, { encMap, invMap });
            }
            const map = (mode === 'encrypt') ? encMap : invMap;
            const newData = new Uint8ClampedArray(data.length);
            for (let dstIdx = 0; dstIdx < totalPixels; dstIdx++) {
                const srcIdx = map[dstIdx];
                newData[dstIdx*4] = data[srcIdx*4];
                newData[dstIdx*4+1] = data[srcIdx*4+1];
                newData[dstIdx*4+2] = data[srcIdx*4+2];
                newData[dstIdx*4+3] = data[srcIdx*4+3];
            }
            ctx.putImageData(new ImageData(newData, width, height), 0, 0);
            const format = imgFormatSelect.value;
            let mime, quality;
            if (format === 'jpg95') { mime = 'image/jpeg'; quality = 0.95; }
            else if (format === 'png') { mime = 'image/png'; quality = undefined; }
            else { mime = 'image/webp'; quality = 1.0; }
            const blob = await canvas.convertToBlob({ type: mime, quality: quality });
            const ext = mime.split('/')[1];
            const baseName = file.name.replace(/\.[^/.]+$/, '');
            const suffix = (mode==='encrypt'?'_encrypted':'_decrypted');
            return { blob, name: `${baseName}${suffix}.${ext}` };
        }

        async function updateFirstImageCache() {
            if (selectedImageFiles.length === 0) { cachedFirstImageWidth = cachedFirstImageHeight = null; cachedFirstImageName = ''; return; }
            try {
                const file = selectedImageFiles[0];
                const bitmap = await createImageBitmap(file);
                cachedFirstImageWidth = bitmap.width; cachedFirstImageHeight = bitmap.height; cachedFirstImageName = file.name;
                bitmap.close();
            } catch (e) { console.warn(e); cachedFirstImageWidth = cachedFirstImageHeight = null; cachedFirstImageName = ''; }
        }

        function fillBlockOptions(width, height) {
            const widthFactors = [], heightFactors = [];
            for (let i = 1; i <= width; i++) if (width % i === 0) widthFactors.push(i);
            for (let i = 1; i <= height; i++) if (height % i === 0) heightFactors.push(i);
            imgBlockWidthSelect.innerHTML = widthFactors.map(v => `<option value="${v}">${v}</option>`).join('');
            imgBlockHeightSelect.innerHTML = heightFactors.map(v => `<option value="${v}">${v}</option>`).join('');
            imgBlockWidthSelect.value = '1'; imgBlockHeightSelect.value = '1'; imgBlockW = 1; imgBlockH = 1;
            imgBlockWidthSelect.disabled = false; imgBlockHeightSelect.disabled = false; standardizeBtn.disabled = false;
            imgBlockWidthSelect.size = Math.min(5, imgBlockWidthSelect.options.length);
            imgBlockHeightSelect.size = Math.min(5, imgBlockHeightSelect.options.length);
            updateBlockHintAndVars();
        }
        function updateBlockHintAndVars() {
            if (selectedImageFiles.length === 0 || !cachedFirstImageWidth) { blockHint.innerText = 'è¯·å…ˆé€‰æ‹©å›¾ç‰‡'; return; }
            const w = parseInt(imgBlockWidthSelect.value,10); const h = parseInt(imgBlockHeightSelect.value,10);
            if (isNaN(w)||isNaN(h)||w===0||h===0) return;
            if (cachedFirstImageWidth % w !== 0 || cachedFirstImageHeight % h !== 0) blockHint.innerText = 'è­¦å‘Šï¼šå—å¤§å°ä¸èƒ½æ•´é™¤å›¾åƒï¼Œå°†äº§ç”Ÿä¸å®Œæ•´å—';
            else { const rows = cachedFirstImageWidth / w; const cols = cachedFirstImageHeight / h; blockHint.innerText = `å¯ç”¨åˆ†å—ï¼š${rows} åˆ— Ã— ${cols} è¡Œ = ${rows*cols} å—`; }
            imgBlockW = w; imgBlockH = h;
        }
        async function updateBlockSizeOptions() {
            imgBlockWidthSelect.disabled = true; imgBlockHeightSelect.disabled = true; standardizeBtn.disabled = true;
            if (selectedImageFiles.length === 0) {
                imgBlockWidthSelect.innerHTML = '<option>è¯·å…ˆé€‰æ‹©å›¾ç‰‡</option>'; imgBlockHeightSelect.innerHTML = '<option>è¯·å…ˆé€‰æ‹©å›¾ç‰‡</option>'; blockHint.innerText = ''; return;
            }
            if (selectedImageFiles.length > 1) {
                imgBlockWidthSelect.innerHTML = '<option value="1" selected>1 (å¤šæ–‡ä»¶æ¨¡å¼)</option>'; imgBlockHeightSelect.innerHTML = '<option value="1" selected>1 (å¤šæ–‡ä»¶æ¨¡å¼)</option>';
                imgBlockW = 1; imgBlockH = 1; blockHint.innerText = 'å¤šæ–‡ä»¶æ¨¡å¼ä¸‹å—å¤§å°å›ºå®šä¸º1Ã—1ï¼ˆåƒç´ çº§æ‰“ä¹±ï¼‰';
                imgBlockWidthSelect.disabled = false; imgBlockHeightSelect.disabled = false; standardizeBtn.disabled = true;
                imgBlockWidthSelect.size = 1; imgBlockHeightSelect.size = 1; return;
            }
            const file = selectedImageFiles[0];
            if (cachedFirstImageName === file.name && cachedFirstImageWidth && cachedFirstImageHeight) fillBlockOptions(cachedFirstImageWidth, cachedFirstImageHeight);
            else {
                imgBlockWidthSelect.innerHTML = '<option>åŠ è½½å°ºå¯¸ä¸­â€¦</option>'; imgBlockHeightSelect.innerHTML = '<option>åŠ è½½å°ºå¯¸ä¸­â€¦</option>'; blockHint.innerText = 'æ­£åœ¨è§£æå›¾ç‰‡â€¦';
                await updateFirstImageCache();
                if (selectedImageFiles[0] === file && cachedFirstImageName === file.name && cachedFirstImageWidth) fillBlockOptions(cachedFirstImageWidth, cachedFirstImageHeight);
                else { imgBlockWidthSelect.innerHTML = '<option>æ— æ³•è¯»å–å›¾ç‰‡</option>'; imgBlockHeightSelect.innerHTML = '<option>æ— æ³•è¯»å–å›¾ç‰‡</option>'; blockHint.innerText = 'è¯»å–å¤±è´¥'; }
            }
        }

        function disableExportControls() { imgFormatSelect.disabled = true; startEncrypt.disabled = true; startDecrypt.disabled = true; }
        function enableExportControls() { imgFormatSelect.disabled = false; startEncrypt.disabled = false; startDecrypt.disabled = false; }

        function resetToOriginal() {
            if (isProcessing) { alert('è¯·ç­‰å¾…å½“å‰å¤„ç†å®Œæˆ'); return; }
            if (!selectedImageFiles.length) { alert('æ²¡æœ‰å·²é€‰æ‹©çš„å›¾ç‰‡'); return; }
            previewUrls.forEach(url => URL.revokeObjectURL(url));
            previewUrls = selectedImageFiles.map(f => URL.createObjectURL(f));
            currentPreviewIndex = 0; latestProcessedImages = []; latestKeyParams = null;
            downloadAllBtn.classList.remove('highlight');
            imageProgress.value = 0; selectedCountDisplay.value = selectedImageFiles.length + ' å¼ å›¾ç‰‡';
            enableExportControls();
            if (previewModal.style.display === 'flex' && previewUrls.length) { previewImg.src = previewUrls[0]; previewCounter.innerText = `1 / ${previewUrls.length}`; }
        }

        async function handleImages(mode) {
            if (isProcessing) return; if (!selectedImageFiles.length) { alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡æ–‡ä»¶'); return; }
            isProcessing = true; disableExportControls();
            try {
                imageProgress.value = 0; downloadAllBtn.classList.remove('highlight');
                let currentBlockW = imgBlockW, currentBlockH = imgBlockH;
                if (imgMethod === 'block' && selectedImageFiles.length > 1) { currentBlockW = 1; currentBlockH = 1; }
                else if (imgMethod === 'block' && selectedImageFiles.length === 1) {
                    const wVal = parseInt(imgBlockWidthSelect.value,10); const hVal = parseInt(imgBlockHeightSelect.value,10);
                    currentBlockW = (isNaN(wVal)||wVal<1) ? 1 : wVal; currentBlockH = (isNaN(hVal)||hVal<1) ? 1 : hVal;
                }
                const total = selectedImageFiles.length; const results = new Array(total); let completed = 0;
                // ä¿å­˜å½“å‰çš„å¤„ç†ç»“æœï¼Œç”¨äºå åŠ åŠ å¯†
                const previousProcessedImages = [...latestProcessedImages];
                const promises = selectedImageFiles.map(async (file, idx) => {
                    let inputFile = file;
                    // å¯¹äºåŠ å¯†å’Œè§£å¯†æ“ä½œï¼Œéƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡å¤„ç†çš„ç»“æœä½œä¸ºè¾“å…¥ï¼ˆå åŠ å¤„ç†ï¼‰
                    if (previousProcessedImages.length > 0 && idx < previousProcessedImages.length) {
                        // ä»previousProcessedImagesä¸­è·å–ä¸Šä¸€æ¬¡å¤„ç†çš„ç»“æœ
                        const prevResult = previousProcessedImages[idx];
                        if (prevResult) {
                            // å°†blobè½¬æ¢ä¸ºFileå¯¹è±¡
                            inputFile = new File([prevResult.blob], prevResult.name, { type: prevResult.blob.type });
                        }
                    }
                    return processImage(inputFile, mode, currentBlockW, currentBlockH).then(({blob, name}) => { 
                        results[idx] = { blob, name }; 
                        completed++; 
                        imageProgress.value = Math.round((completed/total)*100); 
                    });
                });
                await Promise.all(promises);
                latestProcessedImages = results.filter(r => r !== undefined);
                latestKeyParams = { key: keyInput.value, method: imgMethod, blockW: currentBlockW, blockH: currentBlockH, format: imgFormatSelect.value };
                previewUrls.forEach(url => URL.revokeObjectURL(url));
                previewUrls = latestProcessedImages.map(r => URL.createObjectURL(r.blob));
                currentPreviewIndex = 0;
                const formatText = imgFormatSelect.options[imgFormatSelect.selectedIndex].text;
                downloadAllBtn.classList.add('highlight'); selectedCountDisplay.value = results.length + ' å¼ å›¾ç‰‡';
                if (previewModal.style.display === 'flex' && previewUrls.length) { previewImg.src = previewUrls[0]; previewCounter.innerText = `1 / ${previewUrls.length}`; }
                // åªæœ‰åœ¨å…è®¸é‡åŠ å¯†æ—¶æ‰å¯ç”¨æŒ‰é’®
                if (isReencryptEnabled) {
                    enableExportControls();
                }
            } catch (e) { console.error(e); alert(`å¤„ç†å¤±è´¥: ${e.message}`); enableExportControls(); latestProcessedImages = []; previewUrls.forEach(url => URL.revokeObjectURL(url)); previewUrls = selectedImageFiles.map(f => URL.createObjectURL(f)); imageProgress.value = 0; }
            finally { isProcessing = false; }
        }

        function downloadAll() {
            if (!latestProcessedImages.length) { alert('è¯·å…ˆæ‰§è¡ŒåŠ å¯†æˆ–è§£å¯†æ“ä½œ'); return; }
            const usePack = packCheck.checked; const zip = usePack ? new JSZip() : null;
            const results = latestProcessedImages;
            if (usePack) {
                results.forEach(r => zip.file(r.name, r.blob));
                if (exportKeyCheck.checked && latestKeyParams) {
                    const p = latestKeyParams; const keyText = `# åŠ å¯†å‚æ•°\nå¯†é’¥: ${p.key}\næ–¹å¼: ${p.method}\nå—å®½: ${p.blockW}\nå—é«˜: ${p.blockH}\nå¯¼å‡ºæ ¼å¼: ${p.format}\n`;
                    zip.file('key_and_params.txt', keyText);
                }
                zip.generateAsync({ type: 'blob' }).then(content => saveAs(content, `processed_images_${Date.now()}.zip`));
            } else {
                results.forEach(r => saveAs(r.blob, r.name));
                if (exportKeyCheck.checked && latestKeyParams) {
                    const p = latestKeyParams; const keyText = `å¯†é’¥: ${p.key}\næ–¹å¼: ${p.method}\nå—å®½: ${p.blockW}\nå—é«˜: ${p.blockH}\nå¯¼å‡ºæ ¼å¼: ${p.format}`;
                    saveAs(new Blob([keyText], { type: 'text/plain' }), 'key_params.txt');
                }
            }
        }
        async function exportToFolder() {
            if (!latestProcessedImages.length) { alert('è¯·å…ˆæ‰§è¡ŒåŠ å¯†æˆ–è§£å¯†æ“ä½œ'); return; }
            if (!window.showDirectoryPicker) { downloadAll(); return; }
            try {
                const dirHandle = await window.showDirectoryPicker();
                for (const img of latestProcessedImages) {
                    const fileHandle = await dirHandle.getFileHandle(img.name, { create: true });
                    const writable = await fileHandle.createWritable(); await writable.write(img.blob); await writable.close();
                }
                if (exportKeyCheck.checked && latestKeyParams) {
                    const p = latestKeyParams; const keyText = `å¯†é’¥: ${p.key}\næ–¹å¼: ${p.method}\nå—å®½: ${p.blockW}\nå—é«˜: ${p.blockH}\nå¯¼å‡ºæ ¼å¼: ${p.format}`;
                    const keyBlob = new Blob([keyText], { type: 'text/plain' });
                    const keyHandle = await dirHandle.getFileHandle('key_params.txt', { create: true });
                    const writable = await keyHandle.createWritable(); await writable.write(keyBlob); await writable.close();
                }
                alert(`æˆåŠŸå¯¼å‡º ${latestProcessedImages.length} å¼ å›¾ç‰‡åˆ°æ‰€é€‰æ–‡ä»¶å¤¹ã€‚`);
            } catch (err) { if (err.name !== 'AbortError') { console.error(err); alert('å¯¼å‡ºå¤±è´¥ï¼š' + err.message); } }
        }

        // äº‹ä»¶ç»‘å®š
        browseBtn.addEventListener('click', () => imagePicker.click());
        imagePicker.addEventListener('change', function(e) {
            if (isProcessing) { alert('æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆæˆ–ç‚¹å‡»è¿˜åŸ'); return; }
            const files = Array.from(e.target.files); if (!files.length) return;
            selectedImageFiles = files;
            previewUrls.forEach(url => URL.revokeObjectURL(url));
            previewUrls = files.map(f => URL.createObjectURL(f));
            latestProcessedImages = []; latestKeyParams = null;
            selectedCountDisplay.value = files.length + ' å¼ å›¾ç‰‡';
            imageProgress.value = 0;
            downloadAllBtn.classList.remove('highlight'); enableExportControls();
            updateFirstImageCache().then(() => { if (imgMethod === 'block' && encryptMethodModal.style.display === 'flex') updateBlockSizeOptions(); });
        });
        viewPreviewBtn.addEventListener('click', () => {
            if (previewUrls.length === 0) { alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡'); return; }
            currentPreviewIndex = 0; previewImg.src = previewUrls[0]; previewCounter.innerText = `1 / ${previewUrls.length}`; previewModal.style.display = 'flex';
        });
        window.addEventListener('click', (e) => { if (e.target === previewModal) previewModal.style.display = 'none'; });
        prevBtn.addEventListener('click', () => { if (previewUrls.length === 0) return; currentPreviewIndex = (currentPreviewIndex - 1 + previewUrls.length) % previewUrls.length; previewImg.src = previewUrls[currentPreviewIndex]; previewCounter.innerText = `${currentPreviewIndex+1} / ${previewUrls.length}`; });
        nextBtn.addEventListener('click', () => { if (previewUrls.length === 0) return; currentPreviewIndex = (currentPreviewIndex + 1) % previewUrls.length; previewImg.src = previewUrls[currentPreviewIndex]; previewCounter.innerText = `${currentPreviewIndex+1} / ${previewUrls.length}`; });
        randomKeyBtn.addEventListener('click', () => { keyInput.value = Math.random().toString(36).substring(2, 10); });
        copyKeyBtn.addEventListener('click', () => { navigator.clipboard?.writeText(keyInput.value).then(() => alert('å¯†é’¥å·²å¤åˆ¶')); });
        startEncrypt.addEventListener('click', () => handleImages('encrypt'));
        startDecrypt.addEventListener('click', () => handleImages('decrypt'));
        downloadAllBtn.addEventListener('click', downloadAll);
        exportConfigBtn.addEventListener('click', exportToFolder);
        resetBtn.addEventListener('click', resetToOriginal);
        chooseMethodBtn.addEventListener('click', () => {
            document.querySelector(`input[name="imgEncryptMode"][value="${imgMethod}"]`).checked = true;
            imgBlockParamsDiv.style.display = imgMethod === 'block' ? 'block' : 'none';
            if (imgMethod === 'block') updateBlockSizeOptions();
            encryptMethodModal.style.display = 'flex';
        });
        imgEncryptRadios.forEach(radio => { radio.addEventListener('change', (e) => { const show = e.target.value === 'block'; imgBlockParamsDiv.style.display = show ? 'block' : 'none'; if (show) updateBlockSizeOptions(); }); });
        standardizeBtn.addEventListener('click', () => {
            if (selectedImageFiles.length > 1) return;
            const wVal = imgBlockWidthSelect.value; if (!wVal) return;
            let exists = Array.from(imgBlockHeightSelect.options).some(opt => opt.value === wVal);
            if (!exists) { const newOpt = document.createElement('option'); newOpt.value = wVal; newOpt.text = wVal + ' (è‡ªå®šä¹‰)'; imgBlockHeightSelect.appendChild(newOpt); }
            imgBlockHeightSelect.value = wVal; imgBlockH = parseInt(wVal,10); updateBlockHintAndVars();
            imgBlockHeightSelect.size = Math.min(5, imgBlockHeightSelect.options.length);
        });
        saveEncryptMethodBtn.addEventListener('click', () => {
            const selected = document.querySelector('input[name="imgEncryptMode"]:checked').value;
            imgMethod = selected;
            currentMethodDisplay.innerText = (selected === 'gilbert') ? 'å‰å°”ä¼¯ç‰¹æ›²çº¿' : 'åˆ†å—æ‰“ä¹±';
            if (selected === 'block') {
                if (selectedImageFiles.length > 1) { imgBlockW = 1; imgBlockH = 1; }
                else { const wVal = parseInt(imgBlockWidthSelect.value,10); const hVal = parseInt(imgBlockHeightSelect.value,10); imgBlockW = (isNaN(wVal)||wVal<1)?1:wVal; imgBlockH = (isNaN(hVal)||hVal<1)?1:hVal; }
            }
            encryptMethodModal.style.display = 'none';
        });
        window.addEventListener('click', (e) => { if (e.target === encryptMethodModal) encryptMethodModal.style.display = 'none'; });
        imgBlockWidthSelect.addEventListener('change', updateBlockHintAndVars);
        imgBlockHeightSelect.addEventListener('change', updateBlockHintAndVars);
        previewImg.addEventListener('click', function(e) { e.stopPropagation(); if (document.fullscreenElement) document.exitFullscreen(); else this.requestFullscreen(); });
        window.saveAs = window.saveAs || function(blob, name) { const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = name; link.click(); URL.revokeObjectURL(link.href); };
    })();

    // ==================== æ ‡ç­¾é¡µåˆ‡æ¢ & åˆ·æ–° (ç‹¬ç«‹) ====================
    (function() {
        const tabVideo = document.getElementById('tabVideoDecode');
        const tabImage = document.getElementById('tabImageDecode');
        const pageVideo = document.getElementById('videoPage');
        const pageImage = document.getElementById('imagePage');
        const refreshBtn = document.getElementById('refreshCurrentBtn');

        function switchToTab(tab) {
            if (tab === 'video') {
                tabVideo.classList.add('active'); tabImage.classList.remove('active');
                pageVideo.classList.add('active-page'); pageImage.classList.remove('active-page');
                if (typeof window.videoStopDecoding === 'function') window.videoStopDecoding();
                localStorage.setItem('activeCipherTab', 'video');
            } else {
                tabImage.classList.add('active'); tabVideo.classList.remove('active');
                pageImage.classList.add('active-page'); pageVideo.classList.remove('active-page');
                if (typeof window.videoStopDecoding === 'function') window.videoStopDecoding(); // åœæ­¢è§†é¢‘æ’­æ”¾
                localStorage.setItem('activeCipherTab', 'image');
            }
        }

        const saved = localStorage.getItem('activeCipherTab');
        if (saved === 'image') switchToTab('image'); else switchToTab('video');

        tabVideo.addEventListener('click', () => switchToTab('video'));
        tabImage.addEventListener('click', () => switchToTab('image'));
        refreshBtn.addEventListener('click', () => location.reload());
    })();

    // ==================== è§†é¢‘è§£å¯†å¤±è´¥è¯´æ˜å¼¹çª— ====================
    (function() {
        const decryptFailBtn = document.getElementById('decryptFailBtn');
        const decryptFailModal = document.getElementById('decryptFailModal');
        const closeDecryptFailModalBtn = document.getElementById('closeDecryptFailModalBtn');
        const closeDecryptFailModalBtnBottom = document.getElementById('closeDecryptFailModalBtnBottom');

        // æ˜¾ç¤ºå¼¹çª—
        decryptFailBtn.addEventListener('click', () => {
            decryptFailModal.style.display = 'flex';
        });

        // å…³é—­å¼¹çª—
        closeDecryptFailModalBtn.addEventListener('click', () => {
            decryptFailModal.style.display = 'none';
        });

        closeDecryptFailModalBtnBottom.addEventListener('click', () => {
            decryptFailModal.style.display = 'none';
        });

        // ç‚¹å‡»å¼¹çª—å¤–éƒ¨å…³é—­
        window.addEventListener('click', (e) => {
            if (e.target === decryptFailModal) {
                decryptFailModal.style.display = 'none';
            }
        });
    })();
</script>
</body>

</html>
